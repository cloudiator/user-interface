{"version":3,"sources":["../../node_modules/tslib/tslib.es6.js","ng://cloudiator-rest-api/encoder.ts","ng://cloudiator-rest-api/model/cloudiatorProcess.ts","ng://cloudiator-rest-api/variables.ts","ng://cloudiator-rest-api/configuration.ts","ng://cloudiator-rest-api/api/cloud.service.ts","ng://cloudiator-rest-api/api/job.service.ts","ng://cloudiator-rest-api/api/matchmaking.service.ts","ng://cloudiator-rest-api/api/misc.service.ts","ng://cloudiator-rest-api/api/monitoring.service.ts","ng://cloudiator-rest-api/api/node.service.ts","ng://cloudiator-rest-api/api/process.service.ts","ng://cloudiator-rest-api/api/queue.service.ts","ng://cloudiator-rest-api/api/scale.service.ts","ng://cloudiator-rest-api/api/security.service.ts","ng://cloudiator-rest-api/api/user.service.ts","ng://cloudiator-rest-api/api/yaml.service.ts","ng://cloudiator-rest-api/api/api.ts","ng://cloudiator-rest-api/model/dataSink.ts","ng://cloudiator-rest-api/model/interval.ts","ng://cloudiator-rest-api/model/ipAddressType.ts","ng://cloudiator-rest-api/model/newPlatformRuntime.ts","ng://cloudiator-rest-api/model/location.ts","ng://cloudiator-rest-api/model/monitoringTarget.ts","ng://cloudiator-rest-api/model/newPlatform.ts","ng://cloudiator-rest-api/model/nodeCandidate.ts","ng://cloudiator-rest-api/model/optimization.ts","ng://cloudiator-rest-api/model/scale.ts","ng://cloudiator-rest-api/model/scheduleNew.ts","ng://cloudiator-rest-api/model/tool.ts","ng://cloudiator-rest-api/model/node.ts","ng://cloudiator-rest-api/model/platformRuntime.ts","ng://cloudiator-rest-api/model/schedule.ts","ng://cloudiator-rest-api/model/virtualMachine.ts","ng://cloudiator-rest-api/model/attributeOptimization.ts","ng://cloudiator-rest-api/model/cloud.ts","ng://cloudiator-rest-api/model/lanceInterface.ts","ng://cloudiator-rest-api/model/periodicBehaviour.ts","ng://cloudiator-rest-api/model/platform.ts","ng://cloudiator-rest-api/api/platform.service.ts","ng://cloudiator-rest-api/api.module.ts","ng://cloudiator-rest-api/model/cloudType.ts","ng://cloudiator-rest-api/model/discoveryItemState.ts","ng://cloudiator-rest-api/model/ipVersion.ts","ng://cloudiator-rest-api/model/operatingSystemArchitecture.ts","ng://cloudiator-rest-api/model/operatingSystemFamily.ts","ng://cloudiator-rest-api/model/operatingSystemType.ts","ng://cloudiator-rest-api/model/processMapping.ts","ng://cloudiator-rest-api/model/queueStatus.ts","ng://cloudiator-rest-api/model/requirementOperator.ts","ng://cloudiator-rest-api/model/runtime.ts"],"names":["extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__decorate","decorators","target","key","desc","c","arguments","length","r","getOwnPropertyDescriptor","Reflect","decorate","i","defineProperty","__param","paramIndex","decorator","__metadata","metadataKey","metadataValue","metadata","__values","o","m","Symbol","iterator","call","next","value","done","CloudiatorProcess","CustomHttpUrlEncodingCodec","_super","__","this","constructor","prototype","create","tslib_1.__extends","encodeKey","k","replace","encodeValue","v","HttpUrlEncodingCodec","BASE_PATH","InjectionToken","Configuration","configurationParameters","apiKeys","username","password","accessToken","basePath","withCredentials","selectHeaderContentType","contentTypes","_this","undefined","type","find","x","isJsonMime","selectHeaderAccept","accepts","mime","jsonMime","RegExp","test","toLowerCase","CloudService","httpClient","configuration","defaultHeaders","HttpHeaders","canConsumeForm","consumes","consumes_1","tslib_1.__values","consumes_1_1","addCloud","cloud","observe","reportProgress","Error","headers","set","httpHeaderAcceptSelected","httpContentTypeSelected","post","addVM","virtualMachineRequest","deleteCloud","id","delete","encodeURIComponent","String","discoveryStatus","get","editHardware","hardware","put","editImage","image","editLocation","location","findCloud","findClouds","findFunctions","findHardware","cloudId","queryParameters","HttpParams","encoder","params","findImages","findLocations","findVMs","getFunction","getHardware","getImage","getLocation","getVM","Injectable","tslib_1.__param","Optional","Inject","HttpClient","JobService","addJob","job","findJob","findJobs","jobGraph","MatchmakingService","findNodeCandidates","nodeRequirements","getNodeCandidate","getSolution","solveMatchmaking","MiscService","installTools","installRequest","MonitoringService","addMonitor","monitor","deleteMonitor","metric","findMonitors","getMonitor","updateMonitor","NodeService","addByon","newNode","addNode","nodeRequest","deleteByon","deleteNode","findByons","findNodes","getNode","ProcessService","addSchedule","schedule","createProcess","process","deleteProcess","deleteSchedule","findProcess","findSchedule","getProcesses","scheduleId","getSchedules","scheduleGraph","QueueService","findQueuedTask","getQueuedTasks","ScaleService","triggerScale","scale","SecurityService","decrypt","text","deleteSecure","encrypt","retrieveSecure","storeSecure","UserService","createTenant","tenant","createUser","user","login","YamlService","parseYAML","yaml","APIS","StateEnum","PENDING","RUNNING","ERROR","DELETED","FINISHED","TypeEnum","LANCE","SPARK","FAAS","SIMULATION","UNKNOWN","DataSink","KAIROSDB","INFLUX","CLI","JMS","Interval","UnitEnum","DAYS","HOURS","MICROSECONDS","MILLISECONDS","MINUTES","NANOSECONDS","SECONDS","NewPlatformRuntime","Location","LocationScopeEnum","PROVIDER","REGION","ZONE","HOST","MonitoringTarget","JOB","TASK","PROCESS","CLOUD","NODE","NewPlatform","HEROKU","OPENSHIFT","CLOUDFOUNDRY","LanguageEnum","PHP","JAVA","RUBY","PYTHON","RuntimeTypeEnum","Standalone","Server","NodeCandidate","NodeCandidateTypeEnum","IAAS","PAAS","BYON","Optimization","ObjectiveEnum","MAXIMIZE","MINIMIZE","Scale","ScaleDirectionEnum","IN","OUT","ScheduleNew","InstantiationEnum","AUTOMATIC","MANUAL","Node","PlatformRuntime","Schedule","VirtualMachine","AttributeOptimization","AggregationEnum","SUM","AVG","Cloud","OK","LanceInterface","ContainerTypeEnum","NATIVE","DOCKER","BOTH","NodeTypeEnum","UNKNOWNTYPE","VM","CONTAINER","PeriodicBehaviour","CollisionHandlingEnum","CANCEL","PARALLEL","SKIP","Platform","RESTORING","PlatformService","addPlatform","platform","addPlatformEnvironment","platformEnvironment","addPlatformHardware","platformHardware","addPlatformRuntime","platformRuntime","deletePlatform","findPlatform","findPlatformEnvironment","findPlatformEnvironments","findPlatformHardware","findPlatformHardwares","findPlatformRuntime","findPlatformRuntimes","findPlatforms","ApiModule","parentModule","http","forRoot","configurationFactory","ngModule","ApiModule_1","providers","provide","useFactory","NgModule","imports","declarations","exports","SkipSelf","csv","tsv","ssv","pipes","PRIVATE","PUBLIC","NEW","REMOTELYDELETED","LOCALLYDELETED","DISABLED","PUBLICIP","PRIVATEIP","V4","V6","AMD64","UNKOWN","I386","ARM","UBUNTU","UNKOWNOSFAMILY","AIX","ARCH","CENTOS","DARWIN","DEBIAN","ESX","FEDORA","FREEBSD","GENTOO","HPUX","COREOS","AMZNLINUX","MANDRIVA","NETBSD","OEL","OPENBSD","RHEL","SCIENTIFIC","CEL","SLACKWARE","SOLARIS","SUSE","TURBOLINUX","CLOUDLINUX","WINDOWS","LINUX","UNIX","WINDOWSOS","BSD","MAC","SINGLE","CLUSTER","SCHEDULED","COMPLETED","FAILED","EQ","LEQ","GEQ","GT","LT","NEQ","Nodejs","Python","Java","Dotnet","Go","VISOR","AXE","SPARKWORKER","DLMSAGENT","ALLUXIOCLIENT","EMSCLIENT"],"mappings":"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","sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","    import { HttpUrlEncodingCodec } from '@angular/common/http';\r\n\r\n/**\r\n* CustomHttpUrlEncodingCodec\r\n* Fix plus sign (+) not encoding, so sent as blank space\r\n* See: https://github.com/angular/angular/issues/11058#issuecomment-247367318\r\n*/\r\nexport class CustomHttpUrlEncodingCodec extends HttpUrlEncodingCodec {\r\n    encodeKey(k: string): string {\r\n        k = super.encodeKey(k);\r\n        return k.replace(/\\+/gi, '%2B');\r\n    }\r\n    encodeValue(v: string): string {\r\n        v = super.encodeValue(v);\r\n        return v.replace(/\\+/gi, '%2B');\r\n    }\r\n}\r\n\r\n","/**\r\n * Cloudiator REST Api\r\n * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)\r\n *\r\n * OpenAPI spec version: 0.2.0\r\n * Contact: daniel.baur@uni-ulm.de\r\n *\r\n * NOTE: This class is auto generated by the swagger code generator program.\r\n * https://github.com/swagger-api/swagger-codegen.git\r\n * Do not edit the class manually.\r\n */\r\nimport { IpAddress } from './ipAddress';\r\n\r\n\r\nexport interface CloudiatorProcess { \r\n    id?: string;\r\n    originId?: string;\r\n    processType?: string;\r\n    state?: CloudiatorProcess.StateEnum;\r\n    type?: CloudiatorProcess.TypeEnum;\r\n    /**\r\n     * The id of the schedule this process belongs to.\r\n     */\r\n    schedule?: string;\r\n    /**\r\n     * The id of the task that is instantiated by this process.\r\n     */\r\n    task?: string;\r\n    /**\r\n     * The task interface used for running the process.\r\n     */\r\n    taskInterface?: string;\r\n    /**\r\n     * Diagnostic information about this process\r\n     */\r\n    diagnostic?: string;\r\n    /**\r\n     * Reason this process was created\r\n     */\r\n    reason?: string;\r\n    /**\r\n     * The user this process was created for\r\n     */\r\n    owner?: string;\r\n    /**\r\n     * The public/private ip addresses under which this process is reachable. \r\n     */\r\n    ipAddresses?: Array<IpAddress>;\r\n    /**\r\n     * The endpoint where this process is reachable. \r\n     */\r\n    endpoint?: string;\r\n}\r\nexport namespace CloudiatorProcess {\r\n    export type StateEnum = 'PENDING' | 'RUNNING' | 'ERROR' | 'DELETED' | 'FINISHED';\r\n    export const StateEnum = {\r\n        PENDING: 'PENDING' as StateEnum,\r\n        RUNNING: 'RUNNING' as StateEnum,\r\n        ERROR: 'ERROR' as StateEnum,\r\n        DELETED: 'DELETED' as StateEnum,\r\n        FINISHED: 'FINISHED' as StateEnum\r\n    };\r\n    export type TypeEnum = 'LANCE' | 'SPARK' | 'FAAS' | 'SIMULATION' | 'UNKNOWN';\r\n    export const TypeEnum = {\r\n        LANCE: 'LANCE' as TypeEnum,\r\n        SPARK: 'SPARK' as TypeEnum,\r\n        FAAS: 'FAAS' as TypeEnum,\r\n        SIMULATION: 'SIMULATION' as TypeEnum,\r\n        UNKNOWN: 'UNKNOWN' as TypeEnum\r\n    };\r\n}\r\n","import { InjectionToken } from '@angular/core';\r\n\r\nexport const BASE_PATH = new InjectionToken<string>('basePath');\r\nexport const COLLECTION_FORMATS = {\r\n    'csv': ',',\r\n    'tsv': '   ',\r\n    'ssv': ' ',\r\n    'pipes': '|'\r\n}\r\n","export interface ConfigurationParameters {\r\n    apiKeys?: {[ key: string ]: string};\r\n    username?: string;\r\n    password?: string;\r\n    accessToken?: string | (() => string);\r\n    basePath?: string;\r\n    withCredentials?: boolean;\r\n}\r\n\r\nexport class Configuration {\r\n    apiKeys?: {[ key: string ]: string};\r\n    username?: string;\r\n    password?: string;\r\n    accessToken?: string | (() => string);\r\n    basePath?: string;\r\n    withCredentials?: boolean;\r\n\r\n    constructor(configurationParameters: ConfigurationParameters = {}) {\r\n        this.apiKeys = configurationParameters.apiKeys;\r\n        this.username = configurationParameters.username;\r\n        this.password = configurationParameters.password;\r\n        this.accessToken = configurationParameters.accessToken;\r\n        this.basePath = configurationParameters.basePath;\r\n        this.withCredentials = configurationParameters.withCredentials;\r\n    }\r\n\r\n    /**\r\n     * Select the correct content-type to use for a request.\r\n     * Uses {@link Configuration#isJsonMime} to determine the correct content-type.\r\n     * If no content type is found return the first found type if the contentTypes is not empty\r\n     * @param contentTypes - the array of content types that are available for selection\r\n     * @returns the selected content-type or <code>undefined</code> if no selection could be made.\r\n     */\r\n    public selectHeaderContentType (contentTypes: string[]): string | undefined {\r\n        if (contentTypes.length == 0) {\r\n            return undefined;\r\n        }\r\n\r\n        let type = contentTypes.find(x => this.isJsonMime(x));\r\n        if (type === undefined) {\r\n            return contentTypes[0];\r\n        }\r\n        return type;\r\n    }\r\n\r\n    /**\r\n     * Select the correct accept content-type to use for a request.\r\n     * Uses {@link Configuration#isJsonMime} to determine the correct accept content-type.\r\n     * If no content type is found return the first found type if the contentTypes is not empty\r\n     * @param accepts - the array of content types that are available for selection.\r\n     * @returns the selected content-type or <code>undefined</code> if no selection could be made.\r\n     */\r\n    public selectHeaderAccept(accepts: string[]): string | undefined {\r\n        if (accepts.length == 0) {\r\n            return undefined;\r\n        }\r\n\r\n        let type = accepts.find(x => this.isJsonMime(x));\r\n        if (type === undefined) {\r\n            return accepts[0];\r\n        }\r\n        return type;\r\n    }\r\n\r\n    /**\r\n     * Check if the given MIME is a JSON MIME.\r\n     * JSON MIME examples:\r\n     *   application/json\r\n     *   application/json; charset=UTF8\r\n     *   APPLICATION/JSON\r\n     *   application/vnd.company+json\r\n     * @param mime - MIME (Multipurpose Internet Mail Extensions)\r\n     * @return True if the given MIME is JSON, false otherwise.\r\n     */\r\n    public isJsonMime(mime: string): boolean {\r\n        const jsonMime: RegExp = new RegExp('^(application\\/json|[^;/ \\t]+\\/[^;/ \\t]+[+]json)[ \\t]*(;.*)?$', 'i');\r\n        return mime != null && (jsonMime.test(mime) || mime.toLowerCase() === 'application/json-patch+json');\r\n    }\r\n}\r\n","/**\r\n * Cloudiator REST Api\r\n * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)\r\n *\r\n * OpenAPI spec version: 0.2.0\r\n * Contact: daniel.baur@uni-ulm.de\r\n *\r\n * NOTE: This class is auto generated by the swagger code generator program.\r\n * https://github.com/swagger-api/swagger-codegen.git\r\n * Do not edit the class manually.\r\n */\r\n/* tslint:disable:no-unused-variable member-ordering */\r\n\r\nimport { Inject, Injectable, Optional }                      from '@angular/core';\r\nimport { HttpClient, HttpHeaders, HttpParams,\r\n         HttpResponse, HttpEvent }                           from '@angular/common/http';\r\nimport { CustomHttpUrlEncodingCodec }                        from '../encoder';\r\n\r\nimport { Observable }                                        from 'rxjs';\r\n\r\nimport { Cloud } from '../model/cloud';\r\nimport { Hardware } from '../model/hardware';\r\nimport { Image } from '../model/image';\r\nimport { Location } from '../model/location';\r\nimport { ModelFunction } from '../model/modelFunction';\r\nimport { NewCloud } from '../model/newCloud';\r\nimport { Queue } from '../model/queue';\r\nimport { VirtualMachine } from '../model/virtualMachine';\r\nimport { VirtualMachineRequest } from '../model/virtualMachineRequest';\r\n\r\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\r\nimport { Configuration }                                     from '../configuration';\r\n\r\n\r\n@Injectable()\r\nexport class CloudService {\r\n\r\n    protected basePath = 'http://localhost:9000';\r\n    public defaultHeaders = new HttpHeaders();\r\n    public configuration = new Configuration();\r\n\r\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {\r\n        if (basePath) {\r\n            this.basePath = basePath;\r\n        }\r\n        if (configuration) {\r\n            this.configuration = configuration;\r\n            this.basePath = basePath || configuration.basePath || this.basePath;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @param consumes string[] mime-types\r\n     * @return true: consumes contains 'multipart/form-data', false: otherwise\r\n     */\r\n    private canConsumeForm(consumes: string[]): boolean {\r\n        const form = 'multipart/form-data';\r\n        for (const consume of consumes) {\r\n            if (form === consume) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n\r\n    /**\r\n     * \r\n     * Creates a new cloud.\r\n     * @param cloud Cloud to add\r\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\r\n     * @param reportProgress flag to report request and response progress.\r\n     */\r\n    public addCloud(cloud: NewCloud, observe?: 'body', reportProgress?: boolean): Observable<Cloud>;\r\n    public addCloud(cloud: NewCloud, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Cloud>>;\r\n    public addCloud(cloud: NewCloud, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Cloud>>;\r\n    public addCloud(cloud: NewCloud, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\r\n\r\n        if (cloud === null || cloud === undefined) {\r\n            throw new Error('Required parameter cloud was null or undefined when calling addCloud.');\r\n        }\r\n\r\n        let headers = this.defaultHeaders;\r\n\r\n        // authentication (ApiKeyAuth) required\r\n        if (this.configuration.apiKeys[\"X-API-Key\"]) {\r\n            headers = headers.set('X-API-Key', this.configuration.apiKeys[\"X-API-Key\"]);\r\n        }\r\n\r\n        // to determine the Accept header\r\n        let httpHeaderAccepts: string[] = [\r\n            'application/json'\r\n        ];\r\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\r\n        if (httpHeaderAcceptSelected != undefined) {\r\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\r\n        }\r\n\r\n        // to determine the Content-Type header\r\n        const consumes: string[] = [\r\n            'application/json'\r\n        ];\r\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\r\n        if (httpContentTypeSelected != undefined) {\r\n            headers = headers.set('Content-Type', httpContentTypeSelected);\r\n        }\r\n\r\n        return this.httpClient.post<Cloud>(`${this.basePath}/clouds`,\r\n            cloud,\r\n            {\r\n                withCredentials: this.configuration.withCredentials,\r\n                headers: headers,\r\n                observe: observe,\r\n                reportProgress: reportProgress\r\n            }\r\n        );\r\n    }\r\n\r\n    /**\r\n     * \r\n     * Creates a new virtual machine request\r\n     * @param virtualMachineRequest VirtualMachine Request\r\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\r\n     * @param reportProgress flag to report request and response progress.\r\n     */\r\n    public addVM(virtualMachineRequest: VirtualMachineRequest, observe?: 'body', reportProgress?: boolean): Observable<Queue>;\r\n    public addVM(virtualMachineRequest: VirtualMachineRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Queue>>;\r\n    public addVM(virtualMachineRequest: VirtualMachineRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Queue>>;\r\n    public addVM(virtualMachineRequest: VirtualMachineRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\r\n\r\n        if (virtualMachineRequest === null || virtualMachineRequest === undefined) {\r\n            throw new Error('Required parameter virtualMachineRequest was null or undefined when calling addVM.');\r\n        }\r\n\r\n        let headers = this.defaultHeaders;\r\n\r\n        // authentication (ApiKeyAuth) required\r\n        if (this.configuration.apiKeys[\"X-API-Key\"]) {\r\n            headers = headers.set('X-API-Key', this.configuration.apiKeys[\"X-API-Key\"]);\r\n        }\r\n\r\n        // to determine the Accept header\r\n        let httpHeaderAccepts: string[] = [\r\n            'application/json'\r\n        ];\r\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\r\n        if (httpHeaderAcceptSelected != undefined) {\r\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\r\n        }\r\n\r\n        // to determine the Content-Type header\r\n        const consumes: string[] = [\r\n            'application/json'\r\n        ];\r\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\r\n        if (httpContentTypeSelected != undefined) {\r\n            headers = headers.set('Content-Type', httpContentTypeSelected);\r\n        }\r\n\r\n        return this.httpClient.post<Queue>(`${this.basePath}/vm`,\r\n            virtualMachineRequest,\r\n            {\r\n                withCredentials: this.configuration.withCredentials,\r\n                headers: headers,\r\n                observe: observe,\r\n                reportProgress: reportProgress\r\n            }\r\n        );\r\n    }\r\n\r\n    /**\r\n     * \r\n     * Deletes the cloud identified by the given id paramater. \r\n     * @param id Unique identifier of the resource\r\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\r\n     * @param reportProgress flag to report request and response progress.\r\n     */\r\n    public deleteCloud(id: string, observe?: 'body', reportProgress?: boolean): Observable<any>;\r\n    public deleteCloud(id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;\r\n    public deleteCloud(id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;\r\n    public deleteCloud(id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\r\n\r\n        if (id === null || id === undefined) {\r\n            throw new Error('Required parameter id was null or undefined when calling deleteCloud.');\r\n        }\r\n\r\n        let headers = this.defaultHeaders;\r\n\r\n        // authentication (ApiKeyAuth) required\r\n        if (this.configuration.apiKeys[\"X-API-Key\"]) {\r\n            headers = headers.set('X-API-Key', this.configuration.apiKeys[\"X-API-Key\"]);\r\n        }\r\n\r\n        // to determine the Accept header\r\n        let httpHeaderAccepts: string[] = [\r\n            'application/json'\r\n        ];\r\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\r\n        if (httpHeaderAcceptSelected != undefined) {\r\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\r\n        }\r\n\r\n        // to determine the Content-Type header\r\n        const consumes: string[] = [\r\n        ];\r\n\r\n        return this.httpClient.delete<any>(`${this.basePath}/clouds/${encodeURIComponent(String(id))}`,\r\n            {\r\n                withCredentials: this.configuration.withCredentials,\r\n                headers: headers,\r\n                observe: observe,\r\n                reportProgress: reportProgress\r\n            }\r\n        );\r\n    }\r\n\r\n    /**\r\n     * \r\n     * Gets the status of the discovery engine \r\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\r\n     * @param reportProgress flag to report request and response progress.\r\n     */\r\n    public discoveryStatus(observe?: 'body', reportProgress?: boolean): Observable<{ [key: string]: string; }>;\r\n    public discoveryStatus(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<{ [key: string]: string; }>>;\r\n    public discoveryStatus(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<{ [key: string]: string; }>>;\r\n    public discoveryStatus(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\r\n\r\n        let headers = this.defaultHeaders;\r\n\r\n        // authentication (ApiKeyAuth) required\r\n        if (this.configuration.apiKeys[\"X-API-Key\"]) {\r\n            headers = headers.set('X-API-Key', this.configuration.apiKeys[\"X-API-Key\"]);\r\n        }\r\n\r\n        // to determine the Accept header\r\n        let httpHeaderAccepts: string[] = [\r\n            'application/json'\r\n        ];\r\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\r\n        if (httpHeaderAcceptSelected != undefined) {\r\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\r\n        }\r\n\r\n        // to determine the Content-Type header\r\n        const consumes: string[] = [\r\n            'application/json'\r\n        ];\r\n\r\n        return this.httpClient.get<{ [key: string]: string; }>(`${this.basePath}/discovery/status`,\r\n            {\r\n                withCredentials: this.configuration.withCredentials,\r\n                headers: headers,\r\n                observe: observe,\r\n                reportProgress: reportProgress\r\n            }\r\n        );\r\n    }\r\n\r\n    /**\r\n     * \r\n     * Updates a specific hardware \r\n     * @param id Unique identifier of the resource\r\n     * @param hardware Hardware to update \r\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\r\n     * @param reportProgress flag to report request and response progress.\r\n     */\r\n    public editHardware(id: string, hardware: Hardware, observe?: 'body', reportProgress?: boolean): Observable<Hardware>;\r\n    public editHardware(id: string, hardware: Hardware, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Hardware>>;\r\n    public editHardware(id: string, hardware: Hardware, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Hardware>>;\r\n    public editHardware(id: string, hardware: Hardware, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\r\n\r\n        if (id === null || id === undefined) {\r\n            throw new Error('Required parameter id was null or undefined when calling editHardware.');\r\n        }\r\n\r\n        if (hardware === null || hardware === undefined) {\r\n            throw new Error('Required parameter hardware was null or undefined when calling editHardware.');\r\n        }\r\n\r\n        let headers = this.defaultHeaders;\r\n\r\n        // authentication (ApiKeyAuth) required\r\n        if (this.configuration.apiKeys[\"X-API-Key\"]) {\r\n            headers = headers.set('X-API-Key', this.configuration.apiKeys[\"X-API-Key\"]);\r\n        }\r\n\r\n        // to determine the Accept header\r\n        let httpHeaderAccepts: string[] = [\r\n            'application/json'\r\n        ];\r\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\r\n        if (httpHeaderAcceptSelected != undefined) {\r\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\r\n        }\r\n\r\n        // to determine the Content-Type header\r\n        const consumes: string[] = [\r\n            'application/json'\r\n        ];\r\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\r\n        if (httpContentTypeSelected != undefined) {\r\n            headers = headers.set('Content-Type', httpContentTypeSelected);\r\n        }\r\n\r\n        return this.httpClient.put<Hardware>(`${this.basePath}/hardware/${encodeURIComponent(String(id))}`,\r\n            hardware,\r\n            {\r\n                withCredentials: this.configuration.withCredentials,\r\n                headers: headers,\r\n                observe: observe,\r\n                reportProgress: reportProgress\r\n            }\r\n        );\r\n    }\r\n\r\n    /**\r\n     * \r\n     * Updates a specific image \r\n     * @param id Unique identifier of the resource\r\n     * @param image Image to update \r\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\r\n     * @param reportProgress flag to report request and response progress.\r\n     */\r\n    public editImage(id: string, image: Image, observe?: 'body', reportProgress?: boolean): Observable<Image>;\r\n    public editImage(id: string, image: Image, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Image>>;\r\n    public editImage(id: string, image: Image, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Image>>;\r\n    public editImage(id: string, image: Image, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\r\n\r\n        if (id === null || id === undefined) {\r\n            throw new Error('Required parameter id was null or undefined when calling editImage.');\r\n        }\r\n\r\n        if (image === null || image === undefined) {\r\n            throw new Error('Required parameter image was null or undefined when calling editImage.');\r\n        }\r\n\r\n        let headers = this.defaultHeaders;\r\n\r\n        // authentication (ApiKeyAuth) required\r\n        if (this.configuration.apiKeys[\"X-API-Key\"]) {\r\n            headers = headers.set('X-API-Key', this.configuration.apiKeys[\"X-API-Key\"]);\r\n        }\r\n\r\n        // to determine the Accept header\r\n        let httpHeaderAccepts: string[] = [\r\n            'application/json'\r\n        ];\r\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\r\n        if (httpHeaderAcceptSelected != undefined) {\r\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\r\n        }\r\n\r\n        // to determine the Content-Type header\r\n        const consumes: string[] = [\r\n            'application/json'\r\n        ];\r\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\r\n        if (httpContentTypeSelected != undefined) {\r\n            headers = headers.set('Content-Type', httpContentTypeSelected);\r\n        }\r\n\r\n        return this.httpClient.put<Image>(`${this.basePath}/images/${encodeURIComponent(String(id))}`,\r\n            image,\r\n            {\r\n                withCredentials: this.configuration.withCredentials,\r\n                headers: headers,\r\n                observe: observe,\r\n                reportProgress: reportProgress\r\n            }\r\n        );\r\n    }\r\n\r\n    /**\r\n     * \r\n     * Updates a specific location \r\n     * @param id Unique identifier of the resource\r\n     * @param location Location to update \r\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\r\n     * @param reportProgress flag to report request and response progress.\r\n     */\r\n    public editLocation(id: string, location: Location, observe?: 'body', reportProgress?: boolean): Observable<Location>;\r\n    public editLocation(id: string, location: Location, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Location>>;\r\n    public editLocation(id: string, location: Location, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Location>>;\r\n    public editLocation(id: string, location: Location, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\r\n\r\n        if (id === null || id === undefined) {\r\n            throw new Error('Required parameter id was null or undefined when calling editLocation.');\r\n        }\r\n\r\n        if (location === null || location === undefined) {\r\n            throw new Error('Required parameter location was null or undefined when calling editLocation.');\r\n        }\r\n\r\n        let headers = this.defaultHeaders;\r\n\r\n        // authentication (ApiKeyAuth) required\r\n        if (this.configuration.apiKeys[\"X-API-Key\"]) {\r\n            headers = headers.set('X-API-Key', this.configuration.apiKeys[\"X-API-Key\"]);\r\n        }\r\n\r\n        // to determine the Accept header\r\n        let httpHeaderAccepts: string[] = [\r\n            'application/json'\r\n        ];\r\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\r\n        if (httpHeaderAcceptSelected != undefined) {\r\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\r\n        }\r\n\r\n        // to determine the Content-Type header\r\n        const consumes: string[] = [\r\n            'application/json'\r\n        ];\r\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\r\n        if (httpContentTypeSelected != undefined) {\r\n            headers = headers.set('Content-Type', httpContentTypeSelected);\r\n        }\r\n\r\n        return this.httpClient.put<Location>(`${this.basePath}/locations/${encodeURIComponent(String(id))}`,\r\n            location,\r\n            {\r\n                withCredentials: this.configuration.withCredentials,\r\n                headers: headers,\r\n                observe: observe,\r\n                reportProgress: reportProgress\r\n            }\r\n        );\r\n    }\r\n\r\n    /**\r\n     * \r\n     * Returns the cloud identified by the given id parameter \r\n     * @param id Unique identifier of the resource\r\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\r\n     * @param reportProgress flag to report request and response progress.\r\n     */\r\n    public findCloud(id: string, observe?: 'body', reportProgress?: boolean): Observable<Cloud>;\r\n    public findCloud(id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Cloud>>;\r\n    public findCloud(id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Cloud>>;\r\n    public findCloud(id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\r\n\r\n        if (id === null || id === undefined) {\r\n            throw new Error('Required parameter id was null or undefined when calling findCloud.');\r\n        }\r\n\r\n        let headers = this.defaultHeaders;\r\n\r\n        // authentication (ApiKeyAuth) required\r\n        if (this.configuration.apiKeys[\"X-API-Key\"]) {\r\n            headers = headers.set('X-API-Key', this.configuration.apiKeys[\"X-API-Key\"]);\r\n        }\r\n\r\n        // to determine the Accept header\r\n        let httpHeaderAccepts: string[] = [\r\n            'application/json'\r\n        ];\r\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\r\n        if (httpHeaderAcceptSelected != undefined) {\r\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\r\n        }\r\n\r\n        // to determine the Content-Type header\r\n        const consumes: string[] = [\r\n        ];\r\n\r\n        return this.httpClient.get<Cloud>(`${this.basePath}/clouds/${encodeURIComponent(String(id))}`,\r\n            {\r\n                withCredentials: this.configuration.withCredentials,\r\n                headers: headers,\r\n                observe: observe,\r\n                reportProgress: reportProgress\r\n            }\r\n        );\r\n    }\r\n\r\n    /**\r\n     * \r\n     * Returns all clouds from the system that the user has access to \r\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\r\n     * @param reportProgress flag to report request and response progress.\r\n     */\r\n    public findClouds(observe?: 'body', reportProgress?: boolean): Observable<Array<Cloud>>;\r\n    public findClouds(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Cloud>>>;\r\n    public findClouds(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Cloud>>>;\r\n    public findClouds(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\r\n\r\n        let headers = this.defaultHeaders;\r\n\r\n        // authentication (ApiKeyAuth) required\r\n        if (this.configuration.apiKeys[\"X-API-Key\"]) {\r\n            headers = headers.set('X-API-Key', this.configuration.apiKeys[\"X-API-Key\"]);\r\n        }\r\n\r\n        // to determine the Accept header\r\n        let httpHeaderAccepts: string[] = [\r\n            'application/json'\r\n        ];\r\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\r\n        if (httpHeaderAcceptSelected != undefined) {\r\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\r\n        }\r\n\r\n        // to determine the Content-Type header\r\n        const consumes: string[] = [\r\n        ];\r\n\r\n        return this.httpClient.get<Array<Cloud>>(`${this.basePath}/clouds`,\r\n            {\r\n                withCredentials: this.configuration.withCredentials,\r\n                headers: headers,\r\n                observe: observe,\r\n                reportProgress: reportProgress\r\n            }\r\n        );\r\n    }\r\n\r\n    /**\r\n     * \r\n     * Finds all functions the user has access to\r\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\r\n     * @param reportProgress flag to report request and response progress.\r\n     */\r\n    public findFunctions(observe?: 'body', reportProgress?: boolean): Observable<Array<ModelFunction>>;\r\n    public findFunctions(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<ModelFunction>>>;\r\n    public findFunctions(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<ModelFunction>>>;\r\n    public findFunctions(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\r\n\r\n        let headers = this.defaultHeaders;\r\n\r\n        // authentication (ApiKeyAuth) required\r\n        if (this.configuration.apiKeys[\"X-API-Key\"]) {\r\n            headers = headers.set('X-API-Key', this.configuration.apiKeys[\"X-API-Key\"]);\r\n        }\r\n\r\n        // to determine the Accept header\r\n        let httpHeaderAccepts: string[] = [\r\n            'application/json'\r\n        ];\r\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\r\n        if (httpHeaderAcceptSelected != undefined) {\r\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\r\n        }\r\n\r\n        // to determine the Content-Type header\r\n        const consumes: string[] = [\r\n            'application/json'\r\n        ];\r\n\r\n        return this.httpClient.get<Array<ModelFunction>>(`${this.basePath}/function`,\r\n            {\r\n                withCredentials: this.configuration.withCredentials,\r\n                headers: headers,\r\n                observe: observe,\r\n                reportProgress: reportProgress\r\n            }\r\n        );\r\n    }\r\n\r\n    /**\r\n     * \r\n     * Returns all hardware visible to the user \r\n     * @param cloudId (Optional) Unique identifier to filter a specific cloud\r\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\r\n     * @param reportProgress flag to report request and response progress.\r\n     */\r\n    public findHardware(cloudId?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<Hardware>>;\r\n    public findHardware(cloudId?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Hardware>>>;\r\n    public findHardware(cloudId?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Hardware>>>;\r\n    public findHardware(cloudId?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\r\n\r\n\r\n        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});\r\n        if (cloudId !== undefined && cloudId !== null) {\r\n            queryParameters = queryParameters.set('cloudId', <any>cloudId);\r\n        }\r\n\r\n        let headers = this.defaultHeaders;\r\n\r\n        // authentication (ApiKeyAuth) required\r\n        if (this.configuration.apiKeys[\"X-API-Key\"]) {\r\n            headers = headers.set('X-API-Key', this.configuration.apiKeys[\"X-API-Key\"]);\r\n        }\r\n\r\n        // to determine the Accept header\r\n        let httpHeaderAccepts: string[] = [\r\n            'application/json'\r\n        ];\r\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\r\n        if (httpHeaderAcceptSelected != undefined) {\r\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\r\n        }\r\n\r\n        // to determine the Content-Type header\r\n        const consumes: string[] = [\r\n        ];\r\n\r\n        return this.httpClient.get<Array<Hardware>>(`${this.basePath}/hardware`,\r\n            {\r\n                params: queryParameters,\r\n                withCredentials: this.configuration.withCredentials,\r\n                headers: headers,\r\n                observe: observe,\r\n                reportProgress: reportProgress\r\n            }\r\n        );\r\n    }\r\n\r\n    /**\r\n     * \r\n     * Returns all images visable to the user \r\n     * @param cloudId (Optional) Unique identifier to filter a specific cloud\r\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\r\n     * @param reportProgress flag to report request and response progress.\r\n     */\r\n    public findImages(cloudId?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<Image>>;\r\n    public findImages(cloudId?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Image>>>;\r\n    public findImages(cloudId?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Image>>>;\r\n    public findImages(cloudId?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\r\n\r\n\r\n        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});\r\n        if (cloudId !== undefined && cloudId !== null) {\r\n            queryParameters = queryParameters.set('cloudId', <any>cloudId);\r\n        }\r\n\r\n        let headers = this.defaultHeaders;\r\n\r\n        // authentication (ApiKeyAuth) required\r\n        if (this.configuration.apiKeys[\"X-API-Key\"]) {\r\n            headers = headers.set('X-API-Key', this.configuration.apiKeys[\"X-API-Key\"]);\r\n        }\r\n\r\n        // to determine the Accept header\r\n        let httpHeaderAccepts: string[] = [\r\n            'application/json'\r\n        ];\r\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\r\n        if (httpHeaderAcceptSelected != undefined) {\r\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\r\n        }\r\n\r\n        // to determine the Content-Type header\r\n        const consumes: string[] = [\r\n        ];\r\n\r\n        return this.httpClient.get<Array<Image>>(`${this.basePath}/images`,\r\n            {\r\n                params: queryParameters,\r\n                withCredentials: this.configuration.withCredentials,\r\n                headers: headers,\r\n                observe: observe,\r\n                reportProgress: reportProgress\r\n            }\r\n        );\r\n    }\r\n\r\n    /**\r\n     * \r\n     * Returns all locations visible to the user \r\n     * @param cloudId (Optional) Unique identifier to filter a specific cloud\r\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\r\n     * @param reportProgress flag to report request and response progress.\r\n     */\r\n    public findLocations(cloudId?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<Location>>;\r\n    public findLocations(cloudId?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Location>>>;\r\n    public findLocations(cloudId?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Location>>>;\r\n    public findLocations(cloudId?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\r\n\r\n\r\n        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});\r\n        if (cloudId !== undefined && cloudId !== null) {\r\n            queryParameters = queryParameters.set('cloudId', <any>cloudId);\r\n        }\r\n\r\n        let headers = this.defaultHeaders;\r\n\r\n        // authentication (ApiKeyAuth) required\r\n        if (this.configuration.apiKeys[\"X-API-Key\"]) {\r\n            headers = headers.set('X-API-Key', this.configuration.apiKeys[\"X-API-Key\"]);\r\n        }\r\n\r\n        // to determine the Accept header\r\n        let httpHeaderAccepts: string[] = [\r\n            'application/json'\r\n        ];\r\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\r\n        if (httpHeaderAcceptSelected != undefined) {\r\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\r\n        }\r\n\r\n        // to determine the Content-Type header\r\n        const consumes: string[] = [\r\n        ];\r\n\r\n        return this.httpClient.get<Array<Location>>(`${this.basePath}/locations`,\r\n            {\r\n                params: queryParameters,\r\n                withCredentials: this.configuration.withCredentials,\r\n                headers: headers,\r\n                observe: observe,\r\n                reportProgress: reportProgress\r\n            }\r\n        );\r\n    }\r\n\r\n    /**\r\n     * \r\n     * Finds all virtual machines the user has access to\r\n     * @param cloudId (Optional) Unique identifier to filter a specific cloud\r\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\r\n     * @param reportProgress flag to report request and response progress.\r\n     */\r\n    public findVMs(cloudId?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<VirtualMachine>>;\r\n    public findVMs(cloudId?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<VirtualMachine>>>;\r\n    public findVMs(cloudId?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<VirtualMachine>>>;\r\n    public findVMs(cloudId?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\r\n\r\n\r\n        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});\r\n        if (cloudId !== undefined && cloudId !== null) {\r\n            queryParameters = queryParameters.set('cloudId', <any>cloudId);\r\n        }\r\n\r\n        let headers = this.defaultHeaders;\r\n\r\n        // authentication (ApiKeyAuth) required\r\n        if (this.configuration.apiKeys[\"X-API-Key\"]) {\r\n            headers = headers.set('X-API-Key', this.configuration.apiKeys[\"X-API-Key\"]);\r\n        }\r\n\r\n        // to determine the Accept header\r\n        let httpHeaderAccepts: string[] = [\r\n            'application/json'\r\n        ];\r\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\r\n        if (httpHeaderAcceptSelected != undefined) {\r\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\r\n        }\r\n\r\n        // to determine the Content-Type header\r\n        const consumes: string[] = [\r\n            'application/json'\r\n        ];\r\n\r\n        return this.httpClient.get<Array<VirtualMachine>>(`${this.basePath}/vm`,\r\n            {\r\n                params: queryParameters,\r\n                withCredentials: this.configuration.withCredentials,\r\n                headers: headers,\r\n                observe: observe,\r\n                reportProgress: reportProgress\r\n            }\r\n        );\r\n    }\r\n\r\n    /**\r\n     * \r\n     * Finds the function identified by the given id parameter\r\n     * @param id Unique identifier of the resource\r\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\r\n     * @param reportProgress flag to report request and response progress.\r\n     */\r\n    public getFunction(id: string, observe?: 'body', reportProgress?: boolean): Observable<ModelFunction>;\r\n    public getFunction(id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ModelFunction>>;\r\n    public getFunction(id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ModelFunction>>;\r\n    public getFunction(id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\r\n\r\n        if (id === null || id === undefined) {\r\n            throw new Error('Required parameter id was null or undefined when calling getFunction.');\r\n        }\r\n\r\n        let headers = this.defaultHeaders;\r\n\r\n        // authentication (ApiKeyAuth) required\r\n        if (this.configuration.apiKeys[\"X-API-Key\"]) {\r\n            headers = headers.set('X-API-Key', this.configuration.apiKeys[\"X-API-Key\"]);\r\n        }\r\n\r\n        // to determine the Accept header\r\n        let httpHeaderAccepts: string[] = [\r\n            'application/json'\r\n        ];\r\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\r\n        if (httpHeaderAcceptSelected != undefined) {\r\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\r\n        }\r\n\r\n        // to determine the Content-Type header\r\n        const consumes: string[] = [\r\n            'application/json'\r\n        ];\r\n\r\n        return this.httpClient.get<ModelFunction>(`${this.basePath}/function/${encodeURIComponent(String(id))}`,\r\n            {\r\n                withCredentials: this.configuration.withCredentials,\r\n                headers: headers,\r\n                observe: observe,\r\n                reportProgress: reportProgress\r\n            }\r\n        );\r\n    }\r\n\r\n    /**\r\n     * \r\n     * Retrieves the hardware with the given id. \r\n     * @param id Unique identifier of the resource\r\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\r\n     * @param reportProgress flag to report request and response progress.\r\n     */\r\n    public getHardware(id: string, observe?: 'body', reportProgress?: boolean): Observable<Hardware>;\r\n    public getHardware(id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Hardware>>;\r\n    public getHardware(id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Hardware>>;\r\n    public getHardware(id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\r\n\r\n        if (id === null || id === undefined) {\r\n            throw new Error('Required parameter id was null or undefined when calling getHardware.');\r\n        }\r\n\r\n        let headers = this.defaultHeaders;\r\n\r\n        // authentication (ApiKeyAuth) required\r\n        if (this.configuration.apiKeys[\"X-API-Key\"]) {\r\n            headers = headers.set('X-API-Key', this.configuration.apiKeys[\"X-API-Key\"]);\r\n        }\r\n\r\n        // to determine the Accept header\r\n        let httpHeaderAccepts: string[] = [\r\n            'application/json'\r\n        ];\r\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\r\n        if (httpHeaderAcceptSelected != undefined) {\r\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\r\n        }\r\n\r\n        // to determine the Content-Type header\r\n        const consumes: string[] = [\r\n            'application/json'\r\n        ];\r\n\r\n        return this.httpClient.get<Hardware>(`${this.basePath}/hardware/${encodeURIComponent(String(id))}`,\r\n            {\r\n                withCredentials: this.configuration.withCredentials,\r\n                headers: headers,\r\n                observe: observe,\r\n                reportProgress: reportProgress\r\n            }\r\n        );\r\n    }\r\n\r\n    /**\r\n     * \r\n     * Retrieves the image with the given id. \r\n     * @param id Unique identifier of the resource\r\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\r\n     * @param reportProgress flag to report request and response progress.\r\n     */\r\n    public getImage(id: string, observe?: 'body', reportProgress?: boolean): Observable<Image>;\r\n    public getImage(id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Image>>;\r\n    public getImage(id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Image>>;\r\n    public getImage(id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\r\n\r\n        if (id === null || id === undefined) {\r\n            throw new Error('Required parameter id was null or undefined when calling getImage.');\r\n        }\r\n\r\n        let headers = this.defaultHeaders;\r\n\r\n        // authentication (ApiKeyAuth) required\r\n        if (this.configuration.apiKeys[\"X-API-Key\"]) {\r\n            headers = headers.set('X-API-Key', this.configuration.apiKeys[\"X-API-Key\"]);\r\n        }\r\n\r\n        // to determine the Accept header\r\n        let httpHeaderAccepts: string[] = [\r\n            'application/json'\r\n        ];\r\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\r\n        if (httpHeaderAcceptSelected != undefined) {\r\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\r\n        }\r\n\r\n        // to determine the Content-Type header\r\n        const consumes: string[] = [\r\n            'application/json'\r\n        ];\r\n\r\n        return this.httpClient.get<Image>(`${this.basePath}/images/${encodeURIComponent(String(id))}`,\r\n            {\r\n                withCredentials: this.configuration.withCredentials,\r\n                headers: headers,\r\n                observe: observe,\r\n                reportProgress: reportProgress\r\n            }\r\n        );\r\n    }\r\n\r\n    /**\r\n     * \r\n     * Retrieves the location with the given id. \r\n     * @param id Unique identifier of the resource\r\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\r\n     * @param reportProgress flag to report request and response progress.\r\n     */\r\n    public getLocation(id: string, observe?: 'body', reportProgress?: boolean): Observable<Location>;\r\n    public getLocation(id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Location>>;\r\n    public getLocation(id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Location>>;\r\n    public getLocation(id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\r\n\r\n        if (id === null || id === undefined) {\r\n            throw new Error('Required parameter id was null or undefined when calling getLocation.');\r\n        }\r\n\r\n        let headers = this.defaultHeaders;\r\n\r\n        // authentication (ApiKeyAuth) required\r\n        if (this.configuration.apiKeys[\"X-API-Key\"]) {\r\n            headers = headers.set('X-API-Key', this.configuration.apiKeys[\"X-API-Key\"]);\r\n        }\r\n\r\n        // to determine the Accept header\r\n        let httpHeaderAccepts: string[] = [\r\n            'application/json'\r\n        ];\r\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\r\n        if (httpHeaderAcceptSelected != undefined) {\r\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\r\n        }\r\n\r\n        // to determine the Content-Type header\r\n        const consumes: string[] = [\r\n            'application/json'\r\n        ];\r\n\r\n        return this.httpClient.get<Location>(`${this.basePath}/locations/${encodeURIComponent(String(id))}`,\r\n            {\r\n                withCredentials: this.configuration.withCredentials,\r\n                headers: headers,\r\n                observe: observe,\r\n                reportProgress: reportProgress\r\n            }\r\n        );\r\n    }\r\n\r\n    /**\r\n     * \r\n     * Finds the virtual machine identified by the given id parameter\r\n     * @param id Unique identifier of the resource\r\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\r\n     * @param reportProgress flag to report request and response progress.\r\n     */\r\n    public getVM(id: string, observe?: 'body', reportProgress?: boolean): Observable<VirtualMachine>;\r\n    public getVM(id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<VirtualMachine>>;\r\n    public getVM(id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<VirtualMachine>>;\r\n    public getVM(id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\r\n\r\n        if (id === null || id === undefined) {\r\n            throw new Error('Required parameter id was null or undefined when calling getVM.');\r\n        }\r\n\r\n        let headers = this.defaultHeaders;\r\n\r\n        // authentication (ApiKeyAuth) required\r\n        if (this.configuration.apiKeys[\"X-API-Key\"]) {\r\n            headers = headers.set('X-API-Key', this.configuration.apiKeys[\"X-API-Key\"]);\r\n        }\r\n\r\n        // to determine the Accept header\r\n        let httpHeaderAccepts: string[] = [\r\n            'application/json'\r\n        ];\r\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\r\n        if (httpHeaderAcceptSelected != undefined) {\r\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\r\n        }\r\n\r\n        // to determine the Content-Type header\r\n        const consumes: string[] = [\r\n            'application/json'\r\n        ];\r\n\r\n        return this.httpClient.get<VirtualMachine>(`${this.basePath}/vm/${encodeURIComponent(String(id))}`,\r\n            {\r\n                withCredentials: this.configuration.withCredentials,\r\n                headers: headers,\r\n                observe: observe,\r\n                reportProgress: reportProgress\r\n            }\r\n        );\r\n    }\r\n\r\n}\r\n","/**\r\n * Cloudiator REST Api\r\n * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)\r\n *\r\n * OpenAPI spec version: 0.2.0\r\n * Contact: daniel.baur@uni-ulm.de\r\n *\r\n * NOTE: This class is auto generated by the swagger code generator program.\r\n * https://github.com/swagger-api/swagger-codegen.git\r\n * Do not edit the class manually.\r\n */\r\n/* tslint:disable:no-unused-variable member-ordering */\r\n\r\nimport { Inject, Injectable, Optional }                      from '@angular/core';\r\nimport { HttpClient, HttpHeaders, HttpParams,\r\n         HttpResponse, HttpEvent }                           from '@angular/common/http';\r\nimport { CustomHttpUrlEncodingCodec }                        from '../encoder';\r\n\r\nimport { Observable }                                        from 'rxjs';\r\n\r\nimport { Job } from '../model/job';\r\nimport { JobNew } from '../model/jobNew';\r\n\r\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\r\nimport { Configuration }                                     from '../configuration';\r\n\r\n\r\n@Injectable()\r\nexport class JobService {\r\n\r\n    protected basePath = 'http://localhost:9000';\r\n    public defaultHeaders = new HttpHeaders();\r\n    public configuration = new Configuration();\r\n\r\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {\r\n        if (basePath) {\r\n            this.basePath = basePath;\r\n        }\r\n        if (configuration) {\r\n            this.configuration = configuration;\r\n            this.basePath = basePath || configuration.basePath || this.basePath;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @param consumes string[] mime-types\r\n     * @return true: consumes contains 'multipart/form-data', false: otherwise\r\n     */\r\n    private canConsumeForm(consumes: string[]): boolean {\r\n        const form = 'multipart/form-data';\r\n        for (const consume of consumes) {\r\n            if (form === consume) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n\r\n    /**\r\n     * \r\n     * Creates a new job\r\n     * @param job Job to be created. \r\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\r\n     * @param reportProgress flag to report request and response progress.\r\n     */\r\n    public addJob(job: JobNew, observe?: 'body', reportProgress?: boolean): Observable<Job>;\r\n    public addJob(job: JobNew, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Job>>;\r\n    public addJob(job: JobNew, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Job>>;\r\n    public addJob(job: JobNew, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\r\n\r\n        if (job === null || job === undefined) {\r\n            throw new Error('Required parameter job was null or undefined when calling addJob.');\r\n        }\r\n\r\n        let headers = this.defaultHeaders;\r\n\r\n        // authentication (ApiKeyAuth) required\r\n        if (this.configuration.apiKeys[\"X-API-Key\"]) {\r\n            headers = headers.set('X-API-Key', this.configuration.apiKeys[\"X-API-Key\"]);\r\n        }\r\n\r\n        // to determine the Accept header\r\n        let httpHeaderAccepts: string[] = [\r\n            'application/json'\r\n        ];\r\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\r\n        if (httpHeaderAcceptSelected != undefined) {\r\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\r\n        }\r\n\r\n        // to determine the Content-Type header\r\n        const consumes: string[] = [\r\n            'application/json'\r\n        ];\r\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\r\n        if (httpContentTypeSelected != undefined) {\r\n            headers = headers.set('Content-Type', httpContentTypeSelected);\r\n        }\r\n\r\n        return this.httpClient.post<Job>(`${this.basePath}/jobs`,\r\n            job,\r\n            {\r\n                withCredentials: this.configuration.withCredentials,\r\n                headers: headers,\r\n                observe: observe,\r\n                reportProgress: reportProgress\r\n            }\r\n        );\r\n    }\r\n\r\n    /**\r\n     * \r\n     * Returns the job with the given id. \r\n     * @param id Unique identifier of the resource\r\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\r\n     * @param reportProgress flag to report request and response progress.\r\n     */\r\n    public findJob(id: string, observe?: 'body', reportProgress?: boolean): Observable<Job>;\r\n    public findJob(id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Job>>;\r\n    public findJob(id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Job>>;\r\n    public findJob(id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\r\n\r\n        if (id === null || id === undefined) {\r\n            throw new Error('Required parameter id was null or undefined when calling findJob.');\r\n        }\r\n\r\n        let headers = this.defaultHeaders;\r\n\r\n        // authentication (ApiKeyAuth) required\r\n        if (this.configuration.apiKeys[\"X-API-Key\"]) {\r\n            headers = headers.set('X-API-Key', this.configuration.apiKeys[\"X-API-Key\"]);\r\n        }\r\n\r\n        // to determine the Accept header\r\n        let httpHeaderAccepts: string[] = [\r\n            'application/json'\r\n        ];\r\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\r\n        if (httpHeaderAcceptSelected != undefined) {\r\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\r\n        }\r\n\r\n        // to determine the Content-Type header\r\n        const consumes: string[] = [\r\n        ];\r\n\r\n        return this.httpClient.get<Job>(`${this.basePath}/jobs/${encodeURIComponent(String(id))}`,\r\n            {\r\n                withCredentials: this.configuration.withCredentials,\r\n                headers: headers,\r\n                observe: observe,\r\n                reportProgress: reportProgress\r\n            }\r\n        );\r\n    }\r\n\r\n    /**\r\n     * \r\n     * Returns all jobs visible to the user \r\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\r\n     * @param reportProgress flag to report request and response progress.\r\n     */\r\n    public findJobs(observe?: 'body', reportProgress?: boolean): Observable<Array<Job>>;\r\n    public findJobs(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Job>>>;\r\n    public findJobs(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Job>>>;\r\n    public findJobs(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\r\n\r\n        let headers = this.defaultHeaders;\r\n\r\n        // authentication (ApiKeyAuth) required\r\n        if (this.configuration.apiKeys[\"X-API-Key\"]) {\r\n            headers = headers.set('X-API-Key', this.configuration.apiKeys[\"X-API-Key\"]);\r\n        }\r\n\r\n        // to determine the Accept header\r\n        let httpHeaderAccepts: string[] = [\r\n            'application/json'\r\n        ];\r\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\r\n        if (httpHeaderAcceptSelected != undefined) {\r\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\r\n        }\r\n\r\n        // to determine the Content-Type header\r\n        const consumes: string[] = [\r\n        ];\r\n\r\n        return this.httpClient.get<Array<Job>>(`${this.basePath}/jobs`,\r\n            {\r\n                withCredentials: this.configuration.withCredentials,\r\n                headers: headers,\r\n                observe: observe,\r\n                reportProgress: reportProgress\r\n            }\r\n        );\r\n    }\r\n\r\n    /**\r\n     * \r\n     * Returns a json graph representation usable by cyctoscape.js \r\n     * @param id Unique identifier of the resource\r\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\r\n     * @param reportProgress flag to report request and response progress.\r\n     */\r\n    public jobGraph(id: string, observe?: 'body', reportProgress?: boolean): Observable<any>;\r\n    public jobGraph(id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;\r\n    public jobGraph(id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;\r\n    public jobGraph(id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\r\n\r\n        if (id === null || id === undefined) {\r\n            throw new Error('Required parameter id was null or undefined when calling jobGraph.');\r\n        }\r\n\r\n        let headers = this.defaultHeaders;\r\n\r\n        // authentication (ApiKeyAuth) required\r\n        if (this.configuration.apiKeys[\"X-API-Key\"]) {\r\n            headers = headers.set('X-API-Key', this.configuration.apiKeys[\"X-API-Key\"]);\r\n        }\r\n\r\n        // to determine the Accept header\r\n        let httpHeaderAccepts: string[] = [\r\n            'application/json'\r\n        ];\r\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\r\n        if (httpHeaderAcceptSelected != undefined) {\r\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\r\n        }\r\n\r\n        // to determine the Content-Type header\r\n        const consumes: string[] = [\r\n        ];\r\n\r\n        return this.httpClient.get<any>(`${this.basePath}/jobs/${encodeURIComponent(String(id))}/graph`,\r\n            {\r\n                withCredentials: this.configuration.withCredentials,\r\n                headers: headers,\r\n                observe: observe,\r\n                reportProgress: reportProgress\r\n            }\r\n        );\r\n    }\r\n\r\n}\r\n","/**\r\n * Cloudiator REST Api\r\n * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)\r\n *\r\n * OpenAPI spec version: 0.2.0\r\n * Contact: daniel.baur@uni-ulm.de\r\n *\r\n * NOTE: This class is auto generated by the swagger code generator program.\r\n * https://github.com/swagger-api/swagger-codegen.git\r\n * Do not edit the class manually.\r\n */\r\n/* tslint:disable:no-unused-variable member-ordering */\r\n\r\nimport { Inject, Injectable, Optional }                      from '@angular/core';\r\nimport { HttpClient, HttpHeaders, HttpParams,\r\n         HttpResponse, HttpEvent }                           from '@angular/common/http';\r\nimport { CustomHttpUrlEncodingCodec }                        from '../encoder';\r\n\r\nimport { Observable }                                        from 'rxjs';\r\n\r\nimport { NodeCandidate } from '../model/nodeCandidate';\r\nimport { NodeRequirements } from '../model/nodeRequirements';\r\nimport { Queue } from '../model/queue';\r\nimport { Requirement } from '../model/requirement';\r\nimport { Solution } from '../model/solution';\r\n\r\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\r\nimport { Configuration }                                     from '../configuration';\r\n\r\n\r\n@Injectable()\r\nexport class MatchmakingService {\r\n\r\n    protected basePath = 'http://localhost:9000';\r\n    public defaultHeaders = new HttpHeaders();\r\n    public configuration = new Configuration();\r\n\r\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {\r\n        if (basePath) {\r\n            this.basePath = basePath;\r\n        }\r\n        if (configuration) {\r\n            this.configuration = configuration;\r\n            this.basePath = basePath || configuration.basePath || this.basePath;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @param consumes string[] mime-types\r\n     * @return true: consumes contains 'multipart/form-data', false: otherwise\r\n     */\r\n    private canConsumeForm(consumes: string[]): boolean {\r\n        const form = 'multipart/form-data';\r\n        for (const consume of consumes) {\r\n            if (form === consume) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n\r\n    /**\r\n     * \r\n     * Returns possible node candidates. \r\n     * @param nodeRequirements Node Request \r\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\r\n     * @param reportProgress flag to report request and response progress.\r\n     */\r\n    public findNodeCandidates(nodeRequirements?: Array<Requirement>, observe?: 'body', reportProgress?: boolean): Observable<Array<NodeCandidate>>;\r\n    public findNodeCandidates(nodeRequirements?: Array<Requirement>, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<NodeCandidate>>>;\r\n    public findNodeCandidates(nodeRequirements?: Array<Requirement>, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<NodeCandidate>>>;\r\n    public findNodeCandidates(nodeRequirements?: Array<Requirement>, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\r\n\r\n\r\n        let headers = this.defaultHeaders;\r\n\r\n        // authentication (ApiKeyAuth) required\r\n        if (this.configuration.apiKeys[\"X-API-Key\"]) {\r\n            headers = headers.set('X-API-Key', this.configuration.apiKeys[\"X-API-Key\"]);\r\n        }\r\n\r\n        // to determine the Accept header\r\n        let httpHeaderAccepts: string[] = [\r\n            'application/json'\r\n        ];\r\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\r\n        if (httpHeaderAcceptSelected != undefined) {\r\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\r\n        }\r\n\r\n        // to determine the Content-Type header\r\n        const consumes: string[] = [\r\n            'application/json'\r\n        ];\r\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\r\n        if (httpContentTypeSelected != undefined) {\r\n            headers = headers.set('Content-Type', httpContentTypeSelected);\r\n        }\r\n\r\n        return this.httpClient.post<Array<NodeCandidate>>(`${this.basePath}/nodeCandidates`,\r\n            nodeRequirements,\r\n            {\r\n                withCredentials: this.configuration.withCredentials,\r\n                headers: headers,\r\n                observe: observe,\r\n                reportProgress: reportProgress\r\n            }\r\n        );\r\n    }\r\n\r\n    /**\r\n     * \r\n     * Returns the node candidate with the given id if it exists. \r\n     * @param id Unique identifier of the resource\r\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\r\n     * @param reportProgress flag to report request and response progress.\r\n     */\r\n    public getNodeCandidate(id: string, observe?: 'body', reportProgress?: boolean): Observable<NodeCandidate>;\r\n    public getNodeCandidate(id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<NodeCandidate>>;\r\n    public getNodeCandidate(id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<NodeCandidate>>;\r\n    public getNodeCandidate(id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\r\n\r\n        if (id === null || id === undefined) {\r\n            throw new Error('Required parameter id was null or undefined when calling getNodeCandidate.');\r\n        }\r\n\r\n        let headers = this.defaultHeaders;\r\n\r\n        // authentication (ApiKeyAuth) required\r\n        if (this.configuration.apiKeys[\"X-API-Key\"]) {\r\n            headers = headers.set('X-API-Key', this.configuration.apiKeys[\"X-API-Key\"]);\r\n        }\r\n\r\n        // to determine the Accept header\r\n        let httpHeaderAccepts: string[] = [\r\n            'application/json'\r\n        ];\r\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\r\n        if (httpHeaderAcceptSelected != undefined) {\r\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\r\n        }\r\n\r\n        // to determine the Content-Type header\r\n        const consumes: string[] = [\r\n            'application/json'\r\n        ];\r\n\r\n        return this.httpClient.get<NodeCandidate>(`${this.basePath}/nodeCandidates/${encodeURIComponent(String(id))}`,\r\n            {\r\n                withCredentials: this.configuration.withCredentials,\r\n                headers: headers,\r\n                observe: observe,\r\n                reportProgress: reportProgress\r\n            }\r\n        );\r\n    }\r\n\r\n    /**\r\n     * \r\n     * Returns a solution of the matchmaking process (if it is still available) \r\n     * @param id Unique identifier of the resource\r\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\r\n     * @param reportProgress flag to report request and response progress.\r\n     */\r\n    public getSolution(id: string, observe?: 'body', reportProgress?: boolean): Observable<Solution>;\r\n    public getSolution(id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Solution>>;\r\n    public getSolution(id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Solution>>;\r\n    public getSolution(id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\r\n\r\n        if (id === null || id === undefined) {\r\n            throw new Error('Required parameter id was null or undefined when calling getSolution.');\r\n        }\r\n\r\n        let headers = this.defaultHeaders;\r\n\r\n        // authentication (ApiKeyAuth) required\r\n        if (this.configuration.apiKeys[\"X-API-Key\"]) {\r\n            headers = headers.set('X-API-Key', this.configuration.apiKeys[\"X-API-Key\"]);\r\n        }\r\n\r\n        // to determine the Accept header\r\n        let httpHeaderAccepts: string[] = [\r\n            'application/json'\r\n        ];\r\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\r\n        if (httpHeaderAcceptSelected != undefined) {\r\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\r\n        }\r\n\r\n        // to determine the Content-Type header\r\n        const consumes: string[] = [\r\n            'application/json'\r\n        ];\r\n\r\n        return this.httpClient.get<Solution>(`${this.basePath}/solution/${encodeURIComponent(String(id))}`,\r\n            {\r\n                withCredentials: this.configuration.withCredentials,\r\n                headers: headers,\r\n                observe: observe,\r\n                reportProgress: reportProgress\r\n            }\r\n        );\r\n    }\r\n\r\n    /**\r\n     * \r\n     * Solves a matchmaking problem\r\n     * @param nodeRequirements The requirements with respect to nodes\r\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\r\n     * @param reportProgress flag to report request and response progress.\r\n     */\r\n    public solveMatchmaking(nodeRequirements: NodeRequirements, observe?: 'body', reportProgress?: boolean): Observable<Queue>;\r\n    public solveMatchmaking(nodeRequirements: NodeRequirements, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Queue>>;\r\n    public solveMatchmaking(nodeRequirements: NodeRequirements, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Queue>>;\r\n    public solveMatchmaking(nodeRequirements: NodeRequirements, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\r\n\r\n        if (nodeRequirements === null || nodeRequirements === undefined) {\r\n            throw new Error('Required parameter nodeRequirements was null or undefined when calling solveMatchmaking.');\r\n        }\r\n\r\n        let headers = this.defaultHeaders;\r\n\r\n        // authentication (ApiKeyAuth) required\r\n        if (this.configuration.apiKeys[\"X-API-Key\"]) {\r\n            headers = headers.set('X-API-Key', this.configuration.apiKeys[\"X-API-Key\"]);\r\n        }\r\n\r\n        // to determine the Accept header\r\n        let httpHeaderAccepts: string[] = [\r\n            'application/json'\r\n        ];\r\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\r\n        if (httpHeaderAcceptSelected != undefined) {\r\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\r\n        }\r\n\r\n        // to determine the Content-Type header\r\n        const consumes: string[] = [\r\n            'application/json'\r\n        ];\r\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\r\n        if (httpContentTypeSelected != undefined) {\r\n            headers = headers.set('Content-Type', httpContentTypeSelected);\r\n        }\r\n\r\n        return this.httpClient.put<Queue>(`${this.basePath}/matchmaking`,\r\n            nodeRequirements,\r\n            {\r\n                withCredentials: this.configuration.withCredentials,\r\n                headers: headers,\r\n                observe: observe,\r\n                reportProgress: reportProgress\r\n            }\r\n        );\r\n    }\r\n\r\n}\r\n","/**\r\n * Cloudiator REST Api\r\n * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)\r\n *\r\n * OpenAPI spec version: 0.2.0\r\n * Contact: daniel.baur@uni-ulm.de\r\n *\r\n * NOTE: This class is auto generated by the swagger code generator program.\r\n * https://github.com/swagger-api/swagger-codegen.git\r\n * Do not edit the class manually.\r\n */\r\n/* tslint:disable:no-unused-variable member-ordering */\r\n\r\nimport { Inject, Injectable, Optional }                      from '@angular/core';\r\nimport { HttpClient, HttpHeaders, HttpParams,\r\n         HttpResponse, HttpEvent }                           from '@angular/common/http';\r\nimport { CustomHttpUrlEncodingCodec }                        from '../encoder';\r\n\r\nimport { Observable }                                        from 'rxjs';\r\n\r\nimport { InstallationRequest } from '../model/installationRequest';\r\n\r\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\r\nimport { Configuration }                                     from '../configuration';\r\n\r\n\r\n@Injectable()\r\nexport class MiscService {\r\n\r\n    protected basePath = 'http://localhost:9000';\r\n    public defaultHeaders = new HttpHeaders();\r\n    public configuration = new Configuration();\r\n\r\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {\r\n        if (basePath) {\r\n            this.basePath = basePath;\r\n        }\r\n        if (configuration) {\r\n            this.configuration = configuration;\r\n            this.basePath = basePath || configuration.basePath || this.basePath;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @param consumes string[] mime-types\r\n     * @return true: consumes contains 'multipart/form-data', false: otherwise\r\n     */\r\n    private canConsumeForm(consumes: string[]): boolean {\r\n        const form = 'multipart/form-data';\r\n        for (const consume of consumes) {\r\n            if (form === consume) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n\r\n    /**\r\n     * \r\n     * Installs Cloudiator tools on provided node\r\n     * @param installRequest a request to install the cloudiator tools on a provided node\r\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\r\n     * @param reportProgress flag to report request and response progress.\r\n     */\r\n    public installTools(installRequest: InstallationRequest, observe?: 'body', reportProgress?: boolean): Observable<any>;\r\n    public installTools(installRequest: InstallationRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;\r\n    public installTools(installRequest: InstallationRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;\r\n    public installTools(installRequest: InstallationRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\r\n\r\n        if (installRequest === null || installRequest === undefined) {\r\n            throw new Error('Required parameter installRequest was null or undefined when calling installTools.');\r\n        }\r\n\r\n        let headers = this.defaultHeaders;\r\n\r\n        // authentication (ApiKeyAuth) required\r\n        if (this.configuration.apiKeys[\"X-API-Key\"]) {\r\n            headers = headers.set('X-API-Key', this.configuration.apiKeys[\"X-API-Key\"]);\r\n        }\r\n\r\n        // to determine the Accept header\r\n        let httpHeaderAccepts: string[] = [\r\n            'application/json'\r\n        ];\r\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\r\n        if (httpHeaderAcceptSelected != undefined) {\r\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\r\n        }\r\n\r\n        // to determine the Content-Type header\r\n        const consumes: string[] = [\r\n            'application/json'\r\n        ];\r\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\r\n        if (httpContentTypeSelected != undefined) {\r\n            headers = headers.set('Content-Type', httpContentTypeSelected);\r\n        }\r\n\r\n        return this.httpClient.post<any>(`${this.basePath}/installer`,\r\n            installRequest,\r\n            {\r\n                withCredentials: this.configuration.withCredentials,\r\n                headers: headers,\r\n                observe: observe,\r\n                reportProgress: reportProgress\r\n            }\r\n        );\r\n    }\r\n\r\n}\r\n","/**\r\n * Cloudiator REST Api\r\n * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)\r\n *\r\n * OpenAPI spec version: 0.2.0\r\n * Contact: daniel.baur@uni-ulm.de\r\n *\r\n * NOTE: This class is auto generated by the swagger code generator program.\r\n * https://github.com/swagger-api/swagger-codegen.git\r\n * Do not edit the class manually.\r\n */\r\n/* tslint:disable:no-unused-variable member-ordering */\r\n\r\nimport { Inject, Injectable, Optional }                      from '@angular/core';\r\nimport { HttpClient, HttpHeaders, HttpParams,\r\n         HttpResponse, HttpEvent }                           from '@angular/common/http';\r\nimport { CustomHttpUrlEncodingCodec }                        from '../encoder';\r\n\r\nimport { Observable }                                        from 'rxjs';\r\n\r\nimport { Monitor } from '../model/monitor';\r\nimport { MonitoringTarget } from '../model/monitoringTarget';\r\n\r\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\r\nimport { Configuration }                                     from '../configuration';\r\n\r\n\r\n@Injectable()\r\nexport class MonitoringService {\r\n\r\n    protected basePath = 'http://localhost:9000';\r\n    public defaultHeaders = new HttpHeaders();\r\n    public configuration = new Configuration();\r\n\r\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {\r\n        if (basePath) {\r\n            this.basePath = basePath;\r\n        }\r\n        if (configuration) {\r\n            this.configuration = configuration;\r\n            this.basePath = basePath || configuration.basePath || this.basePath;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @param consumes string[] mime-types\r\n     * @return true: consumes contains 'multipart/form-data', false: otherwise\r\n     */\r\n    private canConsumeForm(consumes: string[]): boolean {\r\n        const form = 'multipart/form-data';\r\n        for (const consume of consumes) {\r\n            if (form === consume) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n\r\n    /**\r\n     * \r\n     * Creates a monitor \r\n     * @param monitor Monitor to be created \r\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\r\n     * @param reportProgress flag to report request and response progress.\r\n     */\r\n    public addMonitor(monitor: Monitor, observe?: 'body', reportProgress?: boolean): Observable<Monitor>;\r\n    public addMonitor(monitor: Monitor, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Monitor>>;\r\n    public addMonitor(monitor: Monitor, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Monitor>>;\r\n    public addMonitor(monitor: Monitor, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\r\n\r\n        if (monitor === null || monitor === undefined) {\r\n            throw new Error('Required parameter monitor was null or undefined when calling addMonitor.');\r\n        }\r\n\r\n        let headers = this.defaultHeaders;\r\n\r\n        // authentication (ApiKeyAuth) required\r\n        if (this.configuration.apiKeys[\"X-API-Key\"]) {\r\n            headers = headers.set('X-API-Key', this.configuration.apiKeys[\"X-API-Key\"]);\r\n        }\r\n\r\n        // to determine the Accept header\r\n        let httpHeaderAccepts: string[] = [\r\n            'application/json'\r\n        ];\r\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\r\n        if (httpHeaderAcceptSelected != undefined) {\r\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\r\n        }\r\n\r\n        // to determine the Content-Type header\r\n        const consumes: string[] = [\r\n            'application/json'\r\n        ];\r\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\r\n        if (httpContentTypeSelected != undefined) {\r\n            headers = headers.set('Content-Type', httpContentTypeSelected);\r\n        }\r\n\r\n        return this.httpClient.post<Monitor>(`${this.basePath}/monitors`,\r\n            monitor,\r\n            {\r\n                withCredentials: this.configuration.withCredentials,\r\n                headers: headers,\r\n                observe: observe,\r\n                reportProgress: reportProgress\r\n            }\r\n        );\r\n    }\r\n\r\n    /**\r\n     * \r\n     * Deletes the monitor identified by the given metric name. \r\n     * @param metric Unique identifier of a monitor\r\n     * @param target Target of the Monitor \r\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\r\n     * @param reportProgress flag to report request and response progress.\r\n     */\r\n    public deleteMonitor(metric: string, target: MonitoringTarget, observe?: 'body', reportProgress?: boolean): Observable<any>;\r\n    public deleteMonitor(metric: string, target: MonitoringTarget, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;\r\n    public deleteMonitor(metric: string, target: MonitoringTarget, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;\r\n    public deleteMonitor(metric: string, target: MonitoringTarget, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\r\n\r\n        if (metric === null || metric === undefined) {\r\n            throw new Error('Required parameter metric was null or undefined when calling deleteMonitor.');\r\n        }\r\n\r\n        if (target === null || target === undefined) {\r\n            throw new Error('Required parameter target was null or undefined when calling deleteMonitor.');\r\n        }\r\n\r\n        let headers = this.defaultHeaders;\r\n\r\n        // authentication (ApiKeyAuth) required\r\n        if (this.configuration.apiKeys[\"X-API-Key\"]) {\r\n            headers = headers.set('X-API-Key', this.configuration.apiKeys[\"X-API-Key\"]);\r\n        }\r\n\r\n        // to determine the Accept header\r\n        let httpHeaderAccepts: string[] = [\r\n            'application/json'\r\n        ];\r\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\r\n        if (httpHeaderAcceptSelected != undefined) {\r\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\r\n        }\r\n\r\n        // to determine the Content-Type header\r\n        const consumes: string[] = [\r\n        ];\r\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\r\n        if (httpContentTypeSelected != undefined) {\r\n            headers = headers.set('Content-Type', httpContentTypeSelected);\r\n        }\r\n\r\n        return this.httpClient.delete<any>(`${this.basePath}/monitors/${encodeURIComponent(String(metric))}`,\r\n            {\r\n                withCredentials: this.configuration.withCredentials,\r\n                headers: headers,\r\n                observe: observe,\r\n                reportProgress: reportProgress\r\n            }\r\n        );\r\n    }\r\n\r\n    /**\r\n     * \r\n     * Returns all monitors visible to the user \r\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\r\n     * @param reportProgress flag to report request and response progress.\r\n     */\r\n    public findMonitors(observe?: 'body', reportProgress?: boolean): Observable<Array<Monitor>>;\r\n    public findMonitors(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Monitor>>>;\r\n    public findMonitors(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Monitor>>>;\r\n    public findMonitors(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\r\n\r\n        let headers = this.defaultHeaders;\r\n\r\n        // authentication (ApiKeyAuth) required\r\n        if (this.configuration.apiKeys[\"X-API-Key\"]) {\r\n            headers = headers.set('X-API-Key', this.configuration.apiKeys[\"X-API-Key\"]);\r\n        }\r\n\r\n        // to determine the Accept header\r\n        let httpHeaderAccepts: string[] = [\r\n            'application/json'\r\n        ];\r\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\r\n        if (httpHeaderAcceptSelected != undefined) {\r\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\r\n        }\r\n\r\n        // to determine the Content-Type header\r\n        const consumes: string[] = [\r\n        ];\r\n\r\n        return this.httpClient.get<Array<Monitor>>(`${this.basePath}/monitors`,\r\n            {\r\n                withCredentials: this.configuration.withCredentials,\r\n                headers: headers,\r\n                observe: observe,\r\n                reportProgress: reportProgress\r\n            }\r\n        );\r\n    }\r\n\r\n    /**\r\n     * \r\n     * Retrieves the monitor with the given metric name \r\n     * @param metric Unique identifier of a monitor\r\n     * @param target Target of the Monitor \r\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\r\n     * @param reportProgress flag to report request and response progress.\r\n     */\r\n    public getMonitor(metric: string, target: MonitoringTarget, observe?: 'body', reportProgress?: boolean): Observable<Monitor>;\r\n    public getMonitor(metric: string, target: MonitoringTarget, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Monitor>>;\r\n    public getMonitor(metric: string, target: MonitoringTarget, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Monitor>>;\r\n    public getMonitor(metric: string, target: MonitoringTarget, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\r\n\r\n        if (metric === null || metric === undefined) {\r\n            throw new Error('Required parameter metric was null or undefined when calling getMonitor.');\r\n        }\r\n\r\n        if (target === null || target === undefined) {\r\n            throw new Error('Required parameter target was null or undefined when calling getMonitor.');\r\n        }\r\n\r\n        let headers = this.defaultHeaders;\r\n\r\n        // authentication (ApiKeyAuth) required\r\n        if (this.configuration.apiKeys[\"X-API-Key\"]) {\r\n            headers = headers.set('X-API-Key', this.configuration.apiKeys[\"X-API-Key\"]);\r\n        }\r\n\r\n        // to determine the Accept header\r\n        let httpHeaderAccepts: string[] = [\r\n            'application/json'\r\n        ];\r\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\r\n        if (httpHeaderAcceptSelected != undefined) {\r\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\r\n        }\r\n\r\n        // to determine the Content-Type header\r\n        const consumes: string[] = [\r\n        ];\r\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\r\n        if (httpContentTypeSelected != undefined) {\r\n            headers = headers.set('Content-Type', httpContentTypeSelected);\r\n        }\r\n\r\n        return this.httpClient.get<Monitor>(`${this.basePath}/monitors/${encodeURIComponent(String(metric))}`,\r\n            {\r\n                withCredentials: this.configuration.withCredentials,\r\n                headers: headers,\r\n                observe: observe,\r\n                reportProgress: reportProgress\r\n            }\r\n        );\r\n    }\r\n\r\n    /**\r\n     * \r\n     * Updating a monitor \r\n     * @param metric Unique identifier of a monitor\r\n     * @param monitor Monitor to be updated \r\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\r\n     * @param reportProgress flag to report request and response progress.\r\n     */\r\n    public updateMonitor(metric: string, monitor: Monitor, observe?: 'body', reportProgress?: boolean): Observable<Monitor>;\r\n    public updateMonitor(metric: string, monitor: Monitor, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Monitor>>;\r\n    public updateMonitor(metric: string, monitor: Monitor, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Monitor>>;\r\n    public updateMonitor(metric: string, monitor: Monitor, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\r\n\r\n        if (metric === null || metric === undefined) {\r\n            throw new Error('Required parameter metric was null or undefined when calling updateMonitor.');\r\n        }\r\n\r\n        if (monitor === null || monitor === undefined) {\r\n            throw new Error('Required parameter monitor was null or undefined when calling updateMonitor.');\r\n        }\r\n\r\n        let headers = this.defaultHeaders;\r\n\r\n        // authentication (ApiKeyAuth) required\r\n        if (this.configuration.apiKeys[\"X-API-Key\"]) {\r\n            headers = headers.set('X-API-Key', this.configuration.apiKeys[\"X-API-Key\"]);\r\n        }\r\n\r\n        // to determine the Accept header\r\n        let httpHeaderAccepts: string[] = [\r\n            'application/json'\r\n        ];\r\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\r\n        if (httpHeaderAcceptSelected != undefined) {\r\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\r\n        }\r\n\r\n        // to determine the Content-Type header\r\n        const consumes: string[] = [\r\n            'application/json'\r\n        ];\r\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\r\n        if (httpContentTypeSelected != undefined) {\r\n            headers = headers.set('Content-Type', httpContentTypeSelected);\r\n        }\r\n\r\n        return this.httpClient.put<Monitor>(`${this.basePath}/monitors/${encodeURIComponent(String(metric))}`,\r\n            monitor,\r\n            {\r\n                withCredentials: this.configuration.withCredentials,\r\n                headers: headers,\r\n                observe: observe,\r\n                reportProgress: reportProgress\r\n            }\r\n        );\r\n    }\r\n\r\n}\r\n","/**\r\n * Cloudiator REST Api\r\n * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)\r\n *\r\n * OpenAPI spec version: 0.2.0\r\n * Contact: daniel.baur@uni-ulm.de\r\n *\r\n * NOTE: This class is auto generated by the swagger code generator program.\r\n * https://github.com/swagger-api/swagger-codegen.git\r\n * Do not edit the class manually.\r\n */\r\n/* tslint:disable:no-unused-variable member-ordering */\r\n\r\nimport { Inject, Injectable, Optional }                      from '@angular/core';\r\nimport { HttpClient, HttpHeaders, HttpParams,\r\n         HttpResponse, HttpEvent }                           from '@angular/common/http';\r\nimport { CustomHttpUrlEncodingCodec }                        from '../encoder';\r\n\r\nimport { Observable }                                        from 'rxjs';\r\n\r\nimport { ByonNode } from '../model/byonNode';\r\nimport { NewNode } from '../model/newNode';\r\nimport { Node } from '../model/node';\r\nimport { NodeRequest } from '../model/nodeRequest';\r\nimport { Queue } from '../model/queue';\r\n\r\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\r\nimport { Configuration }                                     from '../configuration';\r\n\r\n\r\n@Injectable()\r\nexport class NodeService {\r\n\r\n    protected basePath = 'http://localhost:9000';\r\n    public defaultHeaders = new HttpHeaders();\r\n    public configuration = new Configuration();\r\n\r\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {\r\n        if (basePath) {\r\n            this.basePath = basePath;\r\n        }\r\n        if (configuration) {\r\n            this.configuration = configuration;\r\n            this.basePath = basePath || configuration.basePath || this.basePath;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @param consumes string[] mime-types\r\n     * @return true: consumes contains 'multipart/form-data', false: otherwise\r\n     */\r\n    private canConsumeForm(consumes: string[]): boolean {\r\n        const form = 'multipart/form-data';\r\n        for (const consume of consumes) {\r\n            if (form === consume) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n\r\n    /**\r\n     * \r\n     * Registers an already existing node for usage\r\n     * @param newNode Node to be registered\r\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\r\n     * @param reportProgress flag to report request and response progress.\r\n     */\r\n    public addByon(newNode: NewNode, observe?: 'body', reportProgress?: boolean): Observable<ByonNode>;\r\n    public addByon(newNode: NewNode, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<ByonNode>>;\r\n    public addByon(newNode: NewNode, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<ByonNode>>;\r\n    public addByon(newNode: NewNode, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\r\n\r\n        if (newNode === null || newNode === undefined) {\r\n            throw new Error('Required parameter newNode was null or undefined when calling addByon.');\r\n        }\r\n\r\n        let headers = this.defaultHeaders;\r\n\r\n        // authentication (ApiKeyAuth) required\r\n        if (this.configuration.apiKeys[\"X-API-Key\"]) {\r\n            headers = headers.set('X-API-Key', this.configuration.apiKeys[\"X-API-Key\"]);\r\n        }\r\n\r\n        // to determine the Accept header\r\n        let httpHeaderAccepts: string[] = [\r\n            'application/json'\r\n        ];\r\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\r\n        if (httpHeaderAcceptSelected != undefined) {\r\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\r\n        }\r\n\r\n        // to determine the Content-Type header\r\n        const consumes: string[] = [\r\n            'application/json'\r\n        ];\r\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\r\n        if (httpContentTypeSelected != undefined) {\r\n            headers = headers.set('Content-Type', httpContentTypeSelected);\r\n        }\r\n\r\n        return this.httpClient.post<ByonNode>(`${this.basePath}/byon`,\r\n            newNode,\r\n            {\r\n                withCredentials: this.configuration.withCredentials,\r\n                headers: headers,\r\n                observe: observe,\r\n                reportProgress: reportProgress\r\n            }\r\n        );\r\n    }\r\n\r\n    /**\r\n     * \r\n     * Create a new node request\r\n     * @param nodeRequest Node Request\r\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\r\n     * @param reportProgress flag to report request and response progress.\r\n     */\r\n    public addNode(nodeRequest: NodeRequest, observe?: 'body', reportProgress?: boolean): Observable<Queue>;\r\n    public addNode(nodeRequest: NodeRequest, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Queue>>;\r\n    public addNode(nodeRequest: NodeRequest, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Queue>>;\r\n    public addNode(nodeRequest: NodeRequest, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\r\n\r\n        if (nodeRequest === null || nodeRequest === undefined) {\r\n            throw new Error('Required parameter nodeRequest was null or undefined when calling addNode.');\r\n        }\r\n\r\n        let headers = this.defaultHeaders;\r\n\r\n        // authentication (ApiKeyAuth) required\r\n        if (this.configuration.apiKeys[\"X-API-Key\"]) {\r\n            headers = headers.set('X-API-Key', this.configuration.apiKeys[\"X-API-Key\"]);\r\n        }\r\n\r\n        // to determine the Accept header\r\n        let httpHeaderAccepts: string[] = [\r\n            'application/json'\r\n        ];\r\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\r\n        if (httpHeaderAcceptSelected != undefined) {\r\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\r\n        }\r\n\r\n        // to determine the Content-Type header\r\n        const consumes: string[] = [\r\n            'application/json'\r\n        ];\r\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\r\n        if (httpContentTypeSelected != undefined) {\r\n            headers = headers.set('Content-Type', httpContentTypeSelected);\r\n        }\r\n\r\n        return this.httpClient.post<Queue>(`${this.basePath}/node`,\r\n            nodeRequest,\r\n            {\r\n                withCredentials: this.configuration.withCredentials,\r\n                headers: headers,\r\n                observe: observe,\r\n                reportProgress: reportProgress\r\n            }\r\n        );\r\n    }\r\n\r\n    /**\r\n     * \r\n     * Deletes the already existing node from cloudiator, if not allocated.\r\n     * @param id Unique identifier of the resource\r\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\r\n     * @param reportProgress flag to report request and response progress.\r\n     */\r\n    public deleteByon(id: string, observe?: 'body', reportProgress?: boolean): Observable<Queue>;\r\n    public deleteByon(id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Queue>>;\r\n    public deleteByon(id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Queue>>;\r\n    public deleteByon(id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\r\n\r\n        if (id === null || id === undefined) {\r\n            throw new Error('Required parameter id was null or undefined when calling deleteByon.');\r\n        }\r\n\r\n        let headers = this.defaultHeaders;\r\n\r\n        // authentication (ApiKeyAuth) required\r\n        if (this.configuration.apiKeys[\"X-API-Key\"]) {\r\n            headers = headers.set('X-API-Key', this.configuration.apiKeys[\"X-API-Key\"]);\r\n        }\r\n\r\n        // to determine the Accept header\r\n        let httpHeaderAccepts: string[] = [\r\n            'application/json'\r\n        ];\r\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\r\n        if (httpHeaderAcceptSelected != undefined) {\r\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\r\n        }\r\n\r\n        // to determine the Content-Type header\r\n        const consumes: string[] = [\r\n        ];\r\n\r\n        return this.httpClient.delete<Queue>(`${this.basePath}/byon/${encodeURIComponent(String(id))}`,\r\n            {\r\n                withCredentials: this.configuration.withCredentials,\r\n                headers: headers,\r\n                observe: observe,\r\n                reportProgress: reportProgress\r\n            }\r\n        );\r\n    }\r\n\r\n    /**\r\n     * \r\n     * Deletes the node with the given id.\r\n     * @param id Unique identifier of the resource\r\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\r\n     * @param reportProgress flag to report request and response progress.\r\n     */\r\n    public deleteNode(id: string, observe?: 'body', reportProgress?: boolean): Observable<Queue>;\r\n    public deleteNode(id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Queue>>;\r\n    public deleteNode(id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Queue>>;\r\n    public deleteNode(id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\r\n\r\n        if (id === null || id === undefined) {\r\n            throw new Error('Required parameter id was null or undefined when calling deleteNode.');\r\n        }\r\n\r\n        let headers = this.defaultHeaders;\r\n\r\n        // authentication (ApiKeyAuth) required\r\n        if (this.configuration.apiKeys[\"X-API-Key\"]) {\r\n            headers = headers.set('X-API-Key', this.configuration.apiKeys[\"X-API-Key\"]);\r\n        }\r\n\r\n        // to determine the Accept header\r\n        let httpHeaderAccepts: string[] = [\r\n            'application/json'\r\n        ];\r\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\r\n        if (httpHeaderAcceptSelected != undefined) {\r\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\r\n        }\r\n\r\n        // to determine the Content-Type header\r\n        const consumes: string[] = [\r\n        ];\r\n\r\n        return this.httpClient.delete<Queue>(`${this.basePath}/node/${encodeURIComponent(String(id))}`,\r\n            {\r\n                withCredentials: this.configuration.withCredentials,\r\n                headers: headers,\r\n                observe: observe,\r\n                reportProgress: reportProgress\r\n            }\r\n        );\r\n    }\r\n\r\n    /**\r\n     * \r\n     * Retrieve all BYONs the current user has access to\r\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\r\n     * @param reportProgress flag to report request and response progress.\r\n     */\r\n    public findByons(observe?: 'body', reportProgress?: boolean): Observable<Array<ByonNode>>;\r\n    public findByons(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<ByonNode>>>;\r\n    public findByons(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<ByonNode>>>;\r\n    public findByons(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\r\n\r\n        let headers = this.defaultHeaders;\r\n\r\n        // authentication (ApiKeyAuth) required\r\n        if (this.configuration.apiKeys[\"X-API-Key\"]) {\r\n            headers = headers.set('X-API-Key', this.configuration.apiKeys[\"X-API-Key\"]);\r\n        }\r\n\r\n        // to determine the Accept header\r\n        let httpHeaderAccepts: string[] = [\r\n            'application/json'\r\n        ];\r\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\r\n        if (httpHeaderAcceptSelected != undefined) {\r\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\r\n        }\r\n\r\n        // to determine the Content-Type header\r\n        const consumes: string[] = [\r\n        ];\r\n\r\n        return this.httpClient.get<Array<ByonNode>>(`${this.basePath}/byon`,\r\n            {\r\n                withCredentials: this.configuration.withCredentials,\r\n                headers: headers,\r\n                observe: observe,\r\n                reportProgress: reportProgress\r\n            }\r\n        );\r\n    }\r\n\r\n    /**\r\n     * \r\n     * Retrieve all nodes the current user has access to\r\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\r\n     * @param reportProgress flag to report request and response progress.\r\n     */\r\n    public findNodes(observe?: 'body', reportProgress?: boolean): Observable<Array<Node>>;\r\n    public findNodes(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Node>>>;\r\n    public findNodes(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Node>>>;\r\n    public findNodes(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\r\n\r\n        let headers = this.defaultHeaders;\r\n\r\n        // authentication (ApiKeyAuth) required\r\n        if (this.configuration.apiKeys[\"X-API-Key\"]) {\r\n            headers = headers.set('X-API-Key', this.configuration.apiKeys[\"X-API-Key\"]);\r\n        }\r\n\r\n        // to determine the Accept header\r\n        let httpHeaderAccepts: string[] = [\r\n            'application/json'\r\n        ];\r\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\r\n        if (httpHeaderAcceptSelected != undefined) {\r\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\r\n        }\r\n\r\n        // to determine the Content-Type header\r\n        const consumes: string[] = [\r\n        ];\r\n\r\n        return this.httpClient.get<Array<Node>>(`${this.basePath}/node`,\r\n            {\r\n                withCredentials: this.configuration.withCredentials,\r\n                headers: headers,\r\n                observe: observe,\r\n                reportProgress: reportProgress\r\n            }\r\n        );\r\n    }\r\n\r\n    /**\r\n     * \r\n     * Retrieves the node with the given id.\r\n     * @param id Unique identifier of the resource\r\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\r\n     * @param reportProgress flag to report request and response progress.\r\n     */\r\n    public getNode(id: string, observe?: 'body', reportProgress?: boolean): Observable<Node>;\r\n    public getNode(id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Node>>;\r\n    public getNode(id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Node>>;\r\n    public getNode(id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\r\n\r\n        if (id === null || id === undefined) {\r\n            throw new Error('Required parameter id was null or undefined when calling getNode.');\r\n        }\r\n\r\n        let headers = this.defaultHeaders;\r\n\r\n        // authentication (ApiKeyAuth) required\r\n        if (this.configuration.apiKeys[\"X-API-Key\"]) {\r\n            headers = headers.set('X-API-Key', this.configuration.apiKeys[\"X-API-Key\"]);\r\n        }\r\n\r\n        // to determine the Accept header\r\n        let httpHeaderAccepts: string[] = [\r\n            'application/json'\r\n        ];\r\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\r\n        if (httpHeaderAcceptSelected != undefined) {\r\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\r\n        }\r\n\r\n        // to determine the Content-Type header\r\n        const consumes: string[] = [\r\n        ];\r\n\r\n        return this.httpClient.get<Node>(`${this.basePath}/node/${encodeURIComponent(String(id))}`,\r\n            {\r\n                withCredentials: this.configuration.withCredentials,\r\n                headers: headers,\r\n                observe: observe,\r\n                reportProgress: reportProgress\r\n            }\r\n        );\r\n    }\r\n\r\n}\r\n","/**\r\n * Cloudiator REST Api\r\n * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)\r\n *\r\n * OpenAPI spec version: 0.2.0\r\n * Contact: daniel.baur@uni-ulm.de\r\n *\r\n * NOTE: This class is auto generated by the swagger code generator program.\r\n * https://github.com/swagger-api/swagger-codegen.git\r\n * Do not edit the class manually.\r\n */\r\n/* tslint:disable:no-unused-variable member-ordering */\r\n\r\nimport { Inject, Injectable, Optional }                      from '@angular/core';\r\nimport { HttpClient, HttpHeaders, HttpParams,\r\n         HttpResponse, HttpEvent }                           from '@angular/common/http';\r\nimport { CustomHttpUrlEncodingCodec }                        from '../encoder';\r\n\r\nimport { Observable }                                        from 'rxjs';\r\n\r\nimport { CloudiatorProcess } from '../model/cloudiatorProcess';\r\nimport { CloudiatorProcessNew } from '../model/cloudiatorProcessNew';\r\nimport { Queue } from '../model/queue';\r\nimport { Schedule } from '../model/schedule';\r\nimport { ScheduleNew } from '../model/scheduleNew';\r\n\r\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\r\nimport { Configuration }                                     from '../configuration';\r\n\r\n\r\n@Injectable()\r\nexport class ProcessService {\r\n\r\n    protected basePath = 'http://localhost:9000';\r\n    public defaultHeaders = new HttpHeaders();\r\n    public configuration = new Configuration();\r\n\r\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {\r\n        if (basePath) {\r\n            this.basePath = basePath;\r\n        }\r\n        if (configuration) {\r\n            this.configuration = configuration;\r\n            this.basePath = basePath || configuration.basePath || this.basePath;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @param consumes string[] mime-types\r\n     * @return true: consumes contains 'multipart/form-data', false: otherwise\r\n     */\r\n    private canConsumeForm(consumes: string[]): boolean {\r\n        const form = 'multipart/form-data';\r\n        for (const consume of consumes) {\r\n            if (form === consume) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n\r\n    /**\r\n     * \r\n     * Creates a new schedule \r\n     * @param schedule Schedule to be created \r\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\r\n     * @param reportProgress flag to report request and response progress.\r\n     */\r\n    public addSchedule(schedule: ScheduleNew, observe?: 'body', reportProgress?: boolean): Observable<Queue>;\r\n    public addSchedule(schedule: ScheduleNew, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Queue>>;\r\n    public addSchedule(schedule: ScheduleNew, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Queue>>;\r\n    public addSchedule(schedule: ScheduleNew, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\r\n\r\n        if (schedule === null || schedule === undefined) {\r\n            throw new Error('Required parameter schedule was null or undefined when calling addSchedule.');\r\n        }\r\n\r\n        let headers = this.defaultHeaders;\r\n\r\n        // authentication (ApiKeyAuth) required\r\n        if (this.configuration.apiKeys[\"X-API-Key\"]) {\r\n            headers = headers.set('X-API-Key', this.configuration.apiKeys[\"X-API-Key\"]);\r\n        }\r\n\r\n        // to determine the Accept header\r\n        let httpHeaderAccepts: string[] = [\r\n            'application/json'\r\n        ];\r\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\r\n        if (httpHeaderAcceptSelected != undefined) {\r\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\r\n        }\r\n\r\n        // to determine the Content-Type header\r\n        const consumes: string[] = [\r\n            'application/json'\r\n        ];\r\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\r\n        if (httpContentTypeSelected != undefined) {\r\n            headers = headers.set('Content-Type', httpContentTypeSelected);\r\n        }\r\n\r\n        return this.httpClient.post<Queue>(`${this.basePath}/schedule`,\r\n            schedule,\r\n            {\r\n                withCredentials: this.configuration.withCredentials,\r\n                headers: headers,\r\n                observe: observe,\r\n                reportProgress: reportProgress\r\n            }\r\n        );\r\n    }\r\n\r\n    /**\r\n     * \r\n     * Creates a new process \r\n     * @param process Process to be created \r\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\r\n     * @param reportProgress flag to report request and response progress.\r\n     */\r\n    public createProcess(process: CloudiatorProcessNew, observe?: 'body', reportProgress?: boolean): Observable<Queue>;\r\n    public createProcess(process: CloudiatorProcessNew, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Queue>>;\r\n    public createProcess(process: CloudiatorProcessNew, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Queue>>;\r\n    public createProcess(process: CloudiatorProcessNew, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\r\n\r\n        if (process === null || process === undefined) {\r\n            throw new Error('Required parameter process was null or undefined when calling createProcess.');\r\n        }\r\n\r\n        let headers = this.defaultHeaders;\r\n\r\n        // authentication (ApiKeyAuth) required\r\n        if (this.configuration.apiKeys[\"X-API-Key\"]) {\r\n            headers = headers.set('X-API-Key', this.configuration.apiKeys[\"X-API-Key\"]);\r\n        }\r\n\r\n        // to determine the Accept header\r\n        let httpHeaderAccepts: string[] = [\r\n            'application/json'\r\n        ];\r\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\r\n        if (httpHeaderAcceptSelected != undefined) {\r\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\r\n        }\r\n\r\n        // to determine the Content-Type header\r\n        const consumes: string[] = [\r\n            'application/json'\r\n        ];\r\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\r\n        if (httpContentTypeSelected != undefined) {\r\n            headers = headers.set('Content-Type', httpContentTypeSelected);\r\n        }\r\n\r\n        return this.httpClient.post<Queue>(`${this.basePath}/process`,\r\n            process,\r\n            {\r\n                withCredentials: this.configuration.withCredentials,\r\n                headers: headers,\r\n                observe: observe,\r\n                reportProgress: reportProgress\r\n            }\r\n        );\r\n    }\r\n\r\n    /**\r\n     * \r\n     * Deletes the process corresponding to the given id. \r\n     * @param id Unique identifier of the resource\r\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\r\n     * @param reportProgress flag to report request and response progress.\r\n     */\r\n    public deleteProcess(id: string, observe?: 'body', reportProgress?: boolean): Observable<Queue>;\r\n    public deleteProcess(id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Queue>>;\r\n    public deleteProcess(id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Queue>>;\r\n    public deleteProcess(id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\r\n\r\n        if (id === null || id === undefined) {\r\n            throw new Error('Required parameter id was null or undefined when calling deleteProcess.');\r\n        }\r\n\r\n        let headers = this.defaultHeaders;\r\n\r\n        // authentication (ApiKeyAuth) required\r\n        if (this.configuration.apiKeys[\"X-API-Key\"]) {\r\n            headers = headers.set('X-API-Key', this.configuration.apiKeys[\"X-API-Key\"]);\r\n        }\r\n\r\n        // to determine the Accept header\r\n        let httpHeaderAccepts: string[] = [\r\n            'application/json'\r\n        ];\r\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\r\n        if (httpHeaderAcceptSelected != undefined) {\r\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\r\n        }\r\n\r\n        // to determine the Content-Type header\r\n        const consumes: string[] = [\r\n        ];\r\n\r\n        return this.httpClient.delete<Queue>(`${this.basePath}/process/${encodeURIComponent(String(id))}`,\r\n            {\r\n                withCredentials: this.configuration.withCredentials,\r\n                headers: headers,\r\n                observe: observe,\r\n                reportProgress: reportProgress\r\n            }\r\n        );\r\n    }\r\n\r\n    /**\r\n     * \r\n     * Deletes the schedule identified by the given id and all corresponding processes and nodes. \r\n     * @param id Unique identifier of the resource\r\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\r\n     * @param reportProgress flag to report request and response progress.\r\n     */\r\n    public deleteSchedule(id: string, observe?: 'body', reportProgress?: boolean): Observable<Queue>;\r\n    public deleteSchedule(id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Queue>>;\r\n    public deleteSchedule(id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Queue>>;\r\n    public deleteSchedule(id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\r\n\r\n        if (id === null || id === undefined) {\r\n            throw new Error('Required parameter id was null or undefined when calling deleteSchedule.');\r\n        }\r\n\r\n        let headers = this.defaultHeaders;\r\n\r\n        // authentication (ApiKeyAuth) required\r\n        if (this.configuration.apiKeys[\"X-API-Key\"]) {\r\n            headers = headers.set('X-API-Key', this.configuration.apiKeys[\"X-API-Key\"]);\r\n        }\r\n\r\n        // to determine the Accept header\r\n        let httpHeaderAccepts: string[] = [\r\n            'application/json'\r\n        ];\r\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\r\n        if (httpHeaderAcceptSelected != undefined) {\r\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\r\n        }\r\n\r\n        // to determine the Content-Type header\r\n        const consumes: string[] = [\r\n        ];\r\n\r\n        return this.httpClient.delete<Queue>(`${this.basePath}/schedule/${encodeURIComponent(String(id))}`,\r\n            {\r\n                withCredentials: this.configuration.withCredentials,\r\n                headers: headers,\r\n                observe: observe,\r\n                reportProgress: reportProgress\r\n            }\r\n        );\r\n    }\r\n\r\n    /**\r\n     * \r\n     * Finds the process corresponding to the given id. \r\n     * @param id Unique identifier of the resource\r\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\r\n     * @param reportProgress flag to report request and response progress.\r\n     */\r\n    public findProcess(id: string, observe?: 'body', reportProgress?: boolean): Observable<CloudiatorProcess>;\r\n    public findProcess(id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<CloudiatorProcess>>;\r\n    public findProcess(id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<CloudiatorProcess>>;\r\n    public findProcess(id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\r\n\r\n        if (id === null || id === undefined) {\r\n            throw new Error('Required parameter id was null or undefined when calling findProcess.');\r\n        }\r\n\r\n        let headers = this.defaultHeaders;\r\n\r\n        // authentication (ApiKeyAuth) required\r\n        if (this.configuration.apiKeys[\"X-API-Key\"]) {\r\n            headers = headers.set('X-API-Key', this.configuration.apiKeys[\"X-API-Key\"]);\r\n        }\r\n\r\n        // to determine the Accept header\r\n        let httpHeaderAccepts: string[] = [\r\n            'application/json'\r\n        ];\r\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\r\n        if (httpHeaderAcceptSelected != undefined) {\r\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\r\n        }\r\n\r\n        // to determine the Content-Type header\r\n        const consumes: string[] = [\r\n        ];\r\n\r\n        return this.httpClient.get<CloudiatorProcess>(`${this.basePath}/process/${encodeURIComponent(String(id))}`,\r\n            {\r\n                withCredentials: this.configuration.withCredentials,\r\n                headers: headers,\r\n                observe: observe,\r\n                reportProgress: reportProgress\r\n            }\r\n        );\r\n    }\r\n\r\n    /**\r\n     * \r\n     * Retrieves the schedule identified by parameter id. \r\n     * @param id Unique identifier of the resource\r\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\r\n     * @param reportProgress flag to report request and response progress.\r\n     */\r\n    public findSchedule(id: string, observe?: 'body', reportProgress?: boolean): Observable<Schedule>;\r\n    public findSchedule(id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Schedule>>;\r\n    public findSchedule(id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Schedule>>;\r\n    public findSchedule(id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\r\n\r\n        if (id === null || id === undefined) {\r\n            throw new Error('Required parameter id was null or undefined when calling findSchedule.');\r\n        }\r\n\r\n        let headers = this.defaultHeaders;\r\n\r\n        // authentication (ApiKeyAuth) required\r\n        if (this.configuration.apiKeys[\"X-API-Key\"]) {\r\n            headers = headers.set('X-API-Key', this.configuration.apiKeys[\"X-API-Key\"]);\r\n        }\r\n\r\n        // to determine the Accept header\r\n        let httpHeaderAccepts: string[] = [\r\n            'application/json'\r\n        ];\r\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\r\n        if (httpHeaderAcceptSelected != undefined) {\r\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\r\n        }\r\n\r\n        // to determine the Content-Type header\r\n        const consumes: string[] = [\r\n        ];\r\n\r\n        return this.httpClient.get<Schedule>(`${this.basePath}/schedule/${encodeURIComponent(String(id))}`,\r\n            {\r\n                withCredentials: this.configuration.withCredentials,\r\n                headers: headers,\r\n                observe: observe,\r\n                reportProgress: reportProgress\r\n            }\r\n        );\r\n    }\r\n\r\n    /**\r\n     * \r\n     * Retrieves all process of the current user matching the parameters. \r\n     * @param scheduleId Id of the schedule. \r\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\r\n     * @param reportProgress flag to report request and response progress.\r\n     */\r\n    public getProcesses(scheduleId?: string, observe?: 'body', reportProgress?: boolean): Observable<Array<CloudiatorProcess>>;\r\n    public getProcesses(scheduleId?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<CloudiatorProcess>>>;\r\n    public getProcesses(scheduleId?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<CloudiatorProcess>>>;\r\n    public getProcesses(scheduleId?: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\r\n\r\n\r\n        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});\r\n        if (scheduleId !== undefined && scheduleId !== null) {\r\n            queryParameters = queryParameters.set('scheduleId', <any>scheduleId);\r\n        }\r\n\r\n        let headers = this.defaultHeaders;\r\n\r\n        // authentication (ApiKeyAuth) required\r\n        if (this.configuration.apiKeys[\"X-API-Key\"]) {\r\n            headers = headers.set('X-API-Key', this.configuration.apiKeys[\"X-API-Key\"]);\r\n        }\r\n\r\n        // to determine the Accept header\r\n        let httpHeaderAccepts: string[] = [\r\n            'application/json'\r\n        ];\r\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\r\n        if (httpHeaderAcceptSelected != undefined) {\r\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\r\n        }\r\n\r\n        // to determine the Content-Type header\r\n        const consumes: string[] = [\r\n        ];\r\n\r\n        return this.httpClient.get<Array<CloudiatorProcess>>(`${this.basePath}/process`,\r\n            {\r\n                params: queryParameters,\r\n                withCredentials: this.configuration.withCredentials,\r\n                headers: headers,\r\n                observe: observe,\r\n                reportProgress: reportProgress\r\n            }\r\n        );\r\n    }\r\n\r\n    /**\r\n     * \r\n     * Retrieves all schedules by the current user. \r\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\r\n     * @param reportProgress flag to report request and response progress.\r\n     */\r\n    public getSchedules(observe?: 'body', reportProgress?: boolean): Observable<Array<Schedule>>;\r\n    public getSchedules(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Schedule>>>;\r\n    public getSchedules(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Schedule>>>;\r\n    public getSchedules(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\r\n\r\n        let headers = this.defaultHeaders;\r\n\r\n        // authentication (ApiKeyAuth) required\r\n        if (this.configuration.apiKeys[\"X-API-Key\"]) {\r\n            headers = headers.set('X-API-Key', this.configuration.apiKeys[\"X-API-Key\"]);\r\n        }\r\n\r\n        // to determine the Accept header\r\n        let httpHeaderAccepts: string[] = [\r\n            'application/json'\r\n        ];\r\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\r\n        if (httpHeaderAcceptSelected != undefined) {\r\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\r\n        }\r\n\r\n        // to determine the Content-Type header\r\n        const consumes: string[] = [\r\n        ];\r\n\r\n        return this.httpClient.get<Array<Schedule>>(`${this.basePath}/schedule`,\r\n            {\r\n                withCredentials: this.configuration.withCredentials,\r\n                headers: headers,\r\n                observe: observe,\r\n                reportProgress: reportProgress\r\n            }\r\n        );\r\n    }\r\n\r\n    /**\r\n     * \r\n     * Returns a json graph representation usable by cyctoscape.js \r\n     * @param id Unique identifier of the resource\r\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\r\n     * @param reportProgress flag to report request and response progress.\r\n     */\r\n    public scheduleGraph(id: string, observe?: 'body', reportProgress?: boolean): Observable<any>;\r\n    public scheduleGraph(id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;\r\n    public scheduleGraph(id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;\r\n    public scheduleGraph(id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\r\n\r\n        if (id === null || id === undefined) {\r\n            throw new Error('Required parameter id was null or undefined when calling scheduleGraph.');\r\n        }\r\n\r\n        let headers = this.defaultHeaders;\r\n\r\n        // authentication (ApiKeyAuth) required\r\n        if (this.configuration.apiKeys[\"X-API-Key\"]) {\r\n            headers = headers.set('X-API-Key', this.configuration.apiKeys[\"X-API-Key\"]);\r\n        }\r\n\r\n        // to determine the Accept header\r\n        let httpHeaderAccepts: string[] = [\r\n            'application/json'\r\n        ];\r\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\r\n        if (httpHeaderAcceptSelected != undefined) {\r\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\r\n        }\r\n\r\n        // to determine the Content-Type header\r\n        const consumes: string[] = [\r\n        ];\r\n\r\n        return this.httpClient.get<any>(`${this.basePath}/schedule/${encodeURIComponent(String(id))}/graph`,\r\n            {\r\n                withCredentials: this.configuration.withCredentials,\r\n                headers: headers,\r\n                observe: observe,\r\n                reportProgress: reportProgress\r\n            }\r\n        );\r\n    }\r\n\r\n}\r\n","/**\r\n * Cloudiator REST Api\r\n * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)\r\n *\r\n * OpenAPI spec version: 0.2.0\r\n * Contact: daniel.baur@uni-ulm.de\r\n *\r\n * NOTE: This class is auto generated by the swagger code generator program.\r\n * https://github.com/swagger-api/swagger-codegen.git\r\n * Do not edit the class manually.\r\n */\r\n/* tslint:disable:no-unused-variable member-ordering */\r\n\r\nimport { Inject, Injectable, Optional }                      from '@angular/core';\r\nimport { HttpClient, HttpHeaders, HttpParams,\r\n         HttpResponse, HttpEvent }                           from '@angular/common/http';\r\nimport { CustomHttpUrlEncodingCodec }                        from '../encoder';\r\n\r\nimport { Observable }                                        from 'rxjs';\r\n\r\nimport { Queue } from '../model/queue';\r\n\r\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\r\nimport { Configuration }                                     from '../configuration';\r\n\r\n\r\n@Injectable()\r\nexport class QueueService {\r\n\r\n    protected basePath = 'http://localhost:9000';\r\n    public defaultHeaders = new HttpHeaders();\r\n    public configuration = new Configuration();\r\n\r\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {\r\n        if (basePath) {\r\n            this.basePath = basePath;\r\n        }\r\n        if (configuration) {\r\n            this.configuration = configuration;\r\n            this.basePath = basePath || configuration.basePath || this.basePath;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @param consumes string[] mime-types\r\n     * @return true: consumes contains 'multipart/form-data', false: otherwise\r\n     */\r\n    private canConsumeForm(consumes: string[]): boolean {\r\n        const form = 'multipart/form-data';\r\n        for (const consume of consumes) {\r\n            if (form === consume) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n\r\n    /**\r\n     * \r\n     * Returns the queued task with the given id. \r\n     * @param id Unique identifier of the resource\r\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\r\n     * @param reportProgress flag to report request and response progress.\r\n     */\r\n    public findQueuedTask(id: string, observe?: 'body', reportProgress?: boolean): Observable<Queue>;\r\n    public findQueuedTask(id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Queue>>;\r\n    public findQueuedTask(id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Queue>>;\r\n    public findQueuedTask(id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\r\n\r\n        if (id === null || id === undefined) {\r\n            throw new Error('Required parameter id was null or undefined when calling findQueuedTask.');\r\n        }\r\n\r\n        let headers = this.defaultHeaders;\r\n\r\n        // authentication (ApiKeyAuth) required\r\n        if (this.configuration.apiKeys[\"X-API-Key\"]) {\r\n            headers = headers.set('X-API-Key', this.configuration.apiKeys[\"X-API-Key\"]);\r\n        }\r\n\r\n        // to determine the Accept header\r\n        let httpHeaderAccepts: string[] = [\r\n            'application/json'\r\n        ];\r\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\r\n        if (httpHeaderAcceptSelected != undefined) {\r\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\r\n        }\r\n\r\n        // to determine the Content-Type header\r\n        const consumes: string[] = [\r\n        ];\r\n\r\n        return this.httpClient.get<Queue>(`${this.basePath}/queue/${encodeURIComponent(String(id))}`,\r\n            {\r\n                withCredentials: this.configuration.withCredentials,\r\n                headers: headers,\r\n                observe: observe,\r\n                reportProgress: reportProgress\r\n            }\r\n        );\r\n    }\r\n\r\n    /**\r\n     * \r\n     * Returns all running queued tasks visible to the user \r\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\r\n     * @param reportProgress flag to report request and response progress.\r\n     */\r\n    public getQueuedTasks(observe?: 'body', reportProgress?: boolean): Observable<Array<Queue>>;\r\n    public getQueuedTasks(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Queue>>>;\r\n    public getQueuedTasks(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Queue>>>;\r\n    public getQueuedTasks(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\r\n\r\n        let headers = this.defaultHeaders;\r\n\r\n        // authentication (ApiKeyAuth) required\r\n        if (this.configuration.apiKeys[\"X-API-Key\"]) {\r\n            headers = headers.set('X-API-Key', this.configuration.apiKeys[\"X-API-Key\"]);\r\n        }\r\n\r\n        // to determine the Accept header\r\n        let httpHeaderAccepts: string[] = [\r\n            'application/json'\r\n        ];\r\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\r\n        if (httpHeaderAcceptSelected != undefined) {\r\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\r\n        }\r\n\r\n        // to determine the Content-Type header\r\n        const consumes: string[] = [\r\n        ];\r\n\r\n        return this.httpClient.get<Array<Queue>>(`${this.basePath}/queue`,\r\n            {\r\n                withCredentials: this.configuration.withCredentials,\r\n                headers: headers,\r\n                observe: observe,\r\n                reportProgress: reportProgress\r\n            }\r\n        );\r\n    }\r\n\r\n}\r\n","/**\r\n * Cloudiator REST Api\r\n * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)\r\n *\r\n * OpenAPI spec version: 0.2.0\r\n * Contact: daniel.baur@uni-ulm.de\r\n *\r\n * NOTE: This class is auto generated by the swagger code generator program.\r\n * https://github.com/swagger-api/swagger-codegen.git\r\n * Do not edit the class manually.\r\n */\r\n/* tslint:disable:no-unused-variable member-ordering */\r\n\r\nimport { Inject, Injectable, Optional }                      from '@angular/core';\r\nimport { HttpClient, HttpHeaders, HttpParams,\r\n         HttpResponse, HttpEvent }                           from '@angular/common/http';\r\nimport { CustomHttpUrlEncodingCodec }                        from '../encoder';\r\n\r\nimport { Observable }                                        from 'rxjs';\r\n\r\nimport { Queue } from '../model/queue';\r\nimport { Scale } from '../model/scale';\r\n\r\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\r\nimport { Configuration }                                     from '../configuration';\r\n\r\n\r\n@Injectable()\r\nexport class ScaleService {\r\n\r\n    protected basePath = 'http://localhost:9000';\r\n    public defaultHeaders = new HttpHeaders();\r\n    public configuration = new Configuration();\r\n\r\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {\r\n        if (basePath) {\r\n            this.basePath = basePath;\r\n        }\r\n        if (configuration) {\r\n            this.configuration = configuration;\r\n            this.basePath = basePath || configuration.basePath || this.basePath;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @param consumes string[] mime-types\r\n     * @return true: consumes contains 'multipart/form-data', false: otherwise\r\n     */\r\n    private canConsumeForm(consumes: string[]): boolean {\r\n        const form = 'multipart/form-data';\r\n        for (const consume of consumes) {\r\n            if (form === consume) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n\r\n    /**\r\n     * \r\n     * Triggers a new scaling action \r\n     * @param scale Scaling action to be executed \r\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\r\n     * @param reportProgress flag to report request and response progress.\r\n     */\r\n    public triggerScale(scale: Scale, observe?: 'body', reportProgress?: boolean): Observable<Queue>;\r\n    public triggerScale(scale: Scale, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Queue>>;\r\n    public triggerScale(scale: Scale, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Queue>>;\r\n    public triggerScale(scale: Scale, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\r\n\r\n        if (scale === null || scale === undefined) {\r\n            throw new Error('Required parameter scale was null or undefined when calling triggerScale.');\r\n        }\r\n\r\n        let headers = this.defaultHeaders;\r\n\r\n        // authentication (ApiKeyAuth) required\r\n        if (this.configuration.apiKeys[\"X-API-Key\"]) {\r\n            headers = headers.set('X-API-Key', this.configuration.apiKeys[\"X-API-Key\"]);\r\n        }\r\n\r\n        // to determine the Accept header\r\n        let httpHeaderAccepts: string[] = [\r\n            'application/json'\r\n        ];\r\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\r\n        if (httpHeaderAcceptSelected != undefined) {\r\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\r\n        }\r\n\r\n        // to determine the Content-Type header\r\n        const consumes: string[] = [\r\n            'application/json'\r\n        ];\r\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\r\n        if (httpContentTypeSelected != undefined) {\r\n            headers = headers.set('Content-Type', httpContentTypeSelected);\r\n        }\r\n\r\n        return this.httpClient.post<Queue>(`${this.basePath}/scale`,\r\n            scale,\r\n            {\r\n                withCredentials: this.configuration.withCredentials,\r\n                headers: headers,\r\n                observe: observe,\r\n                reportProgress: reportProgress\r\n            }\r\n        );\r\n    }\r\n\r\n}\r\n","/**\r\n * Cloudiator REST Api\r\n * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)\r\n *\r\n * OpenAPI spec version: 0.2.0\r\n * Contact: daniel.baur@uni-ulm.de\r\n *\r\n * NOTE: This class is auto generated by the swagger code generator program.\r\n * https://github.com/swagger-api/swagger-codegen.git\r\n * Do not edit the class manually.\r\n */\r\n/* tslint:disable:no-unused-variable member-ordering */\r\n\r\nimport { Inject, Injectable, Optional }                      from '@angular/core';\r\nimport { HttpClient, HttpHeaders, HttpParams,\r\n         HttpResponse, HttpEvent }                           from '@angular/common/http';\r\nimport { CustomHttpUrlEncodingCodec }                        from '../encoder';\r\n\r\nimport { Observable }                                        from 'rxjs';\r\n\r\nimport { Text } from '../model/text';\r\n\r\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\r\nimport { Configuration }                                     from '../configuration';\r\n\r\n\r\n@Injectable()\r\nexport class SecurityService {\r\n\r\n    protected basePath = 'http://localhost:9000';\r\n    public defaultHeaders = new HttpHeaders();\r\n    public configuration = new Configuration();\r\n\r\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {\r\n        if (basePath) {\r\n            this.basePath = basePath;\r\n        }\r\n        if (configuration) {\r\n            this.configuration = configuration;\r\n            this.basePath = basePath || configuration.basePath || this.basePath;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @param consumes string[] mime-types\r\n     * @return true: consumes contains 'multipart/form-data', false: otherwise\r\n     */\r\n    private canConsumeForm(consumes: string[]): boolean {\r\n        const form = 'multipart/form-data';\r\n        for (const consume of consumes) {\r\n            if (form === consume) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n\r\n    /**\r\n     * \r\n     * Decrypts the given string\r\n     * @param text Text to decrypt\r\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\r\n     * @param reportProgress flag to report request and response progress.\r\n     */\r\n    public decrypt(text: string, observe?: 'body', reportProgress?: boolean): Observable<Text>;\r\n    public decrypt(text: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Text>>;\r\n    public decrypt(text: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Text>>;\r\n    public decrypt(text: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\r\n\r\n        if (text === null || text === undefined) {\r\n            throw new Error('Required parameter text was null or undefined when calling decrypt.');\r\n        }\r\n\r\n        let headers = this.defaultHeaders;\r\n\r\n        // authentication (ApiKeyAuth) required\r\n        if (this.configuration.apiKeys[\"X-API-Key\"]) {\r\n            headers = headers.set('X-API-Key', this.configuration.apiKeys[\"X-API-Key\"]);\r\n        }\r\n\r\n        // to determine the Accept header\r\n        let httpHeaderAccepts: string[] = [\r\n            'application/json'\r\n        ];\r\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\r\n        if (httpHeaderAcceptSelected != undefined) {\r\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\r\n        }\r\n\r\n        // to determine the Content-Type header\r\n        const consumes: string[] = [\r\n        ];\r\n\r\n        return this.httpClient.get<Text>(`${this.basePath}/decryption/${encodeURIComponent(String(text))}`,\r\n            {\r\n                withCredentials: this.configuration.withCredentials,\r\n                headers: headers,\r\n                observe: observe,\r\n                reportProgress: reportProgress\r\n            }\r\n        );\r\n    }\r\n\r\n    /**\r\n     * \r\n     * \r\n     * @param key Key of the stored variable \r\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\r\n     * @param reportProgress flag to report request and response progress.\r\n     */\r\n    public deleteSecure(key: string, observe?: 'body', reportProgress?: boolean): Observable<any>;\r\n    public deleteSecure(key: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;\r\n    public deleteSecure(key: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;\r\n    public deleteSecure(key: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\r\n\r\n        if (key === null || key === undefined) {\r\n            throw new Error('Required parameter key was null or undefined when calling deleteSecure.');\r\n        }\r\n\r\n        let headers = this.defaultHeaders;\r\n\r\n        // authentication (ApiKeyAuth) required\r\n        if (this.configuration.apiKeys[\"X-API-Key\"]) {\r\n            headers = headers.set('X-API-Key', this.configuration.apiKeys[\"X-API-Key\"]);\r\n        }\r\n\r\n        // to determine the Accept header\r\n        let httpHeaderAccepts: string[] = [\r\n            'application/json'\r\n        ];\r\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\r\n        if (httpHeaderAcceptSelected != undefined) {\r\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\r\n        }\r\n\r\n        // to determine the Content-Type header\r\n        const consumes: string[] = [\r\n            'application/json'\r\n        ];\r\n\r\n        return this.httpClient.delete<any>(`${this.basePath}/secureStore/${encodeURIComponent(String(key))}`,\r\n            {\r\n                withCredentials: this.configuration.withCredentials,\r\n                headers: headers,\r\n                observe: observe,\r\n                reportProgress: reportProgress\r\n            }\r\n        );\r\n    }\r\n\r\n    /**\r\n     * \r\n     * Encrypts the given string\r\n     * @param text Text to encrypt\r\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\r\n     * @param reportProgress flag to report request and response progress.\r\n     */\r\n    public encrypt(text: string, observe?: 'body', reportProgress?: boolean): Observable<Text>;\r\n    public encrypt(text: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Text>>;\r\n    public encrypt(text: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Text>>;\r\n    public encrypt(text: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\r\n\r\n        if (text === null || text === undefined) {\r\n            throw new Error('Required parameter text was null or undefined when calling encrypt.');\r\n        }\r\n\r\n        let headers = this.defaultHeaders;\r\n\r\n        // authentication (ApiKeyAuth) required\r\n        if (this.configuration.apiKeys[\"X-API-Key\"]) {\r\n            headers = headers.set('X-API-Key', this.configuration.apiKeys[\"X-API-Key\"]);\r\n        }\r\n\r\n        // to determine the Accept header\r\n        let httpHeaderAccepts: string[] = [\r\n            'application/json'\r\n        ];\r\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\r\n        if (httpHeaderAcceptSelected != undefined) {\r\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\r\n        }\r\n\r\n        // to determine the Content-Type header\r\n        const consumes: string[] = [\r\n        ];\r\n\r\n        return this.httpClient.get<Text>(`${this.basePath}/encryption/${encodeURIComponent(String(text))}`,\r\n            {\r\n                withCredentials: this.configuration.withCredentials,\r\n                headers: headers,\r\n                observe: observe,\r\n                reportProgress: reportProgress\r\n            }\r\n        );\r\n    }\r\n\r\n    /**\r\n     * \r\n     * Retrieves the stored value. \r\n     * @param key Key of the stored variable \r\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\r\n     * @param reportProgress flag to report request and response progress.\r\n     */\r\n    public retrieveSecure(key: string, observe?: 'body', reportProgress?: boolean): Observable<Text>;\r\n    public retrieveSecure(key: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Text>>;\r\n    public retrieveSecure(key: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Text>>;\r\n    public retrieveSecure(key: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\r\n\r\n        if (key === null || key === undefined) {\r\n            throw new Error('Required parameter key was null or undefined when calling retrieveSecure.');\r\n        }\r\n\r\n        let headers = this.defaultHeaders;\r\n\r\n        // authentication (ApiKeyAuth) required\r\n        if (this.configuration.apiKeys[\"X-API-Key\"]) {\r\n            headers = headers.set('X-API-Key', this.configuration.apiKeys[\"X-API-Key\"]);\r\n        }\r\n\r\n        // to determine the Accept header\r\n        let httpHeaderAccepts: string[] = [\r\n            'application/json'\r\n        ];\r\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\r\n        if (httpHeaderAcceptSelected != undefined) {\r\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\r\n        }\r\n\r\n        // to determine the Content-Type header\r\n        const consumes: string[] = [\r\n        ];\r\n\r\n        return this.httpClient.get<Text>(`${this.basePath}/secureStore/${encodeURIComponent(String(key))}`,\r\n            {\r\n                withCredentials: this.configuration.withCredentials,\r\n                headers: headers,\r\n                observe: observe,\r\n                reportProgress: reportProgress\r\n            }\r\n        );\r\n    }\r\n\r\n    /**\r\n     * \r\n     * \r\n     * @param key Key of the stored variable \r\n     * @param value Value of the stored variable \r\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\r\n     * @param reportProgress flag to report request and response progress.\r\n     */\r\n    public storeSecure(key: string, value: Text, observe?: 'body', reportProgress?: boolean): Observable<Text>;\r\n    public storeSecure(key: string, value: Text, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Text>>;\r\n    public storeSecure(key: string, value: Text, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Text>>;\r\n    public storeSecure(key: string, value: Text, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\r\n\r\n        if (key === null || key === undefined) {\r\n            throw new Error('Required parameter key was null or undefined when calling storeSecure.');\r\n        }\r\n\r\n        if (value === null || value === undefined) {\r\n            throw new Error('Required parameter value was null or undefined when calling storeSecure.');\r\n        }\r\n\r\n        let headers = this.defaultHeaders;\r\n\r\n        // authentication (ApiKeyAuth) required\r\n        if (this.configuration.apiKeys[\"X-API-Key\"]) {\r\n            headers = headers.set('X-API-Key', this.configuration.apiKeys[\"X-API-Key\"]);\r\n        }\r\n\r\n        // to determine the Accept header\r\n        let httpHeaderAccepts: string[] = [\r\n            'application/json'\r\n        ];\r\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\r\n        if (httpHeaderAcceptSelected != undefined) {\r\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\r\n        }\r\n\r\n        // to determine the Content-Type header\r\n        const consumes: string[] = [\r\n            'application/json'\r\n        ];\r\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\r\n        if (httpContentTypeSelected != undefined) {\r\n            headers = headers.set('Content-Type', httpContentTypeSelected);\r\n        }\r\n\r\n        return this.httpClient.put<Text>(`${this.basePath}/secureStore/${encodeURIComponent(String(key))}`,\r\n            value,\r\n            {\r\n                withCredentials: this.configuration.withCredentials,\r\n                headers: headers,\r\n                observe: observe,\r\n                reportProgress: reportProgress\r\n            }\r\n        );\r\n    }\r\n\r\n}\r\n","/**\r\n * Cloudiator REST Api\r\n * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)\r\n *\r\n * OpenAPI spec version: 0.2.0\r\n * Contact: daniel.baur@uni-ulm.de\r\n *\r\n * NOTE: This class is auto generated by the swagger code generator program.\r\n * https://github.com/swagger-api/swagger-codegen.git\r\n * Do not edit the class manually.\r\n */\r\n/* tslint:disable:no-unused-variable member-ordering */\r\n\r\nimport { Inject, Injectable, Optional }                      from '@angular/core';\r\nimport { HttpClient, HttpHeaders, HttpParams,\r\n         HttpResponse, HttpEvent }                           from '@angular/common/http';\r\nimport { CustomHttpUrlEncodingCodec }                        from '../encoder';\r\n\r\nimport { Observable }                                        from 'rxjs';\r\n\r\nimport { Login } from '../model/login';\r\nimport { Tenant } from '../model/tenant';\r\nimport { Token } from '../model/token';\r\nimport { User } from '../model/user';\r\nimport { UserNew } from '../model/userNew';\r\n\r\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\r\nimport { Configuration }                                     from '../configuration';\r\n\r\n\r\n@Injectable()\r\nexport class UserService {\r\n\r\n    protected basePath = 'http://localhost:9000';\r\n    public defaultHeaders = new HttpHeaders();\r\n    public configuration = new Configuration();\r\n\r\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {\r\n        if (basePath) {\r\n            this.basePath = basePath;\r\n        }\r\n        if (configuration) {\r\n            this.configuration = configuration;\r\n            this.basePath = basePath || configuration.basePath || this.basePath;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @param consumes string[] mime-types\r\n     * @return true: consumes contains 'multipart/form-data', false: otherwise\r\n     */\r\n    private canConsumeForm(consumes: string[]): boolean {\r\n        const form = 'multipart/form-data';\r\n        for (const consume of consumes) {\r\n            if (form === consume) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n\r\n    /**\r\n     * \r\n     * Creates a new tenant \r\n     * @param tenant Tenant creation request \r\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\r\n     * @param reportProgress flag to report request and response progress.\r\n     */\r\n    public createTenant(tenant?: Tenant, observe?: 'body', reportProgress?: boolean): Observable<Tenant>;\r\n    public createTenant(tenant?: Tenant, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Tenant>>;\r\n    public createTenant(tenant?: Tenant, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Tenant>>;\r\n    public createTenant(tenant?: Tenant, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\r\n\r\n\r\n        let headers = this.defaultHeaders;\r\n\r\n        // authentication (ApiKeyAuth) required\r\n        if (this.configuration.apiKeys[\"X-API-Key\"]) {\r\n            headers = headers.set('X-API-Key', this.configuration.apiKeys[\"X-API-Key\"]);\r\n        }\r\n\r\n        // to determine the Accept header\r\n        let httpHeaderAccepts: string[] = [\r\n            'application/json'\r\n        ];\r\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\r\n        if (httpHeaderAcceptSelected != undefined) {\r\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\r\n        }\r\n\r\n        // to determine the Content-Type header\r\n        const consumes: string[] = [\r\n            'application/json'\r\n        ];\r\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\r\n        if (httpContentTypeSelected != undefined) {\r\n            headers = headers.set('Content-Type', httpContentTypeSelected);\r\n        }\r\n\r\n        return this.httpClient.post<Tenant>(`${this.basePath}/tenants`,\r\n            tenant,\r\n            {\r\n                withCredentials: this.configuration.withCredentials,\r\n                headers: headers,\r\n                observe: observe,\r\n                reportProgress: reportProgress\r\n            }\r\n        );\r\n    }\r\n\r\n    /**\r\n     * \r\n     * Creates a new user \r\n     * @param user User creation request \r\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\r\n     * @param reportProgress flag to report request and response progress.\r\n     */\r\n    public createUser(user?: UserNew, observe?: 'body', reportProgress?: boolean): Observable<User>;\r\n    public createUser(user?: UserNew, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<User>>;\r\n    public createUser(user?: UserNew, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<User>>;\r\n    public createUser(user?: UserNew, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\r\n\r\n\r\n        let headers = this.defaultHeaders;\r\n\r\n        // authentication (ApiKeyAuth) required\r\n        if (this.configuration.apiKeys[\"X-API-Key\"]) {\r\n            headers = headers.set('X-API-Key', this.configuration.apiKeys[\"X-API-Key\"]);\r\n        }\r\n\r\n        // to determine the Accept header\r\n        let httpHeaderAccepts: string[] = [\r\n            'application/json'\r\n        ];\r\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\r\n        if (httpHeaderAcceptSelected != undefined) {\r\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\r\n        }\r\n\r\n        // to determine the Content-Type header\r\n        const consumes: string[] = [\r\n            'application/json'\r\n        ];\r\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\r\n        if (httpContentTypeSelected != undefined) {\r\n            headers = headers.set('Content-Type', httpContentTypeSelected);\r\n        }\r\n\r\n        return this.httpClient.post<User>(`${this.basePath}/users`,\r\n            user,\r\n            {\r\n                withCredentials: this.configuration.withCredentials,\r\n                headers: headers,\r\n                observe: observe,\r\n                reportProgress: reportProgress\r\n            }\r\n        );\r\n    }\r\n\r\n    /**\r\n     * \r\n     * Authenticates a user \r\n     * @param login User login request \r\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\r\n     * @param reportProgress flag to report request and response progress.\r\n     */\r\n    public login(login?: Login, observe?: 'body', reportProgress?: boolean): Observable<Token>;\r\n    public login(login?: Login, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Token>>;\r\n    public login(login?: Login, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Token>>;\r\n    public login(login?: Login, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\r\n\r\n\r\n        let headers = this.defaultHeaders;\r\n\r\n        // authentication (ApiKeyAuth) required\r\n        if (this.configuration.apiKeys[\"X-API-Key\"]) {\r\n            headers = headers.set('X-API-Key', this.configuration.apiKeys[\"X-API-Key\"]);\r\n        }\r\n\r\n        // to determine the Accept header\r\n        let httpHeaderAccepts: string[] = [\r\n            'application/json'\r\n        ];\r\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\r\n        if (httpHeaderAcceptSelected != undefined) {\r\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\r\n        }\r\n\r\n        // to determine the Content-Type header\r\n        const consumes: string[] = [\r\n            'application/json'\r\n        ];\r\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\r\n        if (httpContentTypeSelected != undefined) {\r\n            headers = headers.set('Content-Type', httpContentTypeSelected);\r\n        }\r\n\r\n        return this.httpClient.post<Token>(`${this.basePath}/login`,\r\n            login,\r\n            {\r\n                withCredentials: this.configuration.withCredentials,\r\n                headers: headers,\r\n                observe: observe,\r\n                reportProgress: reportProgress\r\n            }\r\n        );\r\n    }\r\n\r\n}\r\n","/**\r\n * Cloudiator REST Api\r\n * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)\r\n *\r\n * OpenAPI spec version: 0.2.0\r\n * Contact: daniel.baur@uni-ulm.de\r\n *\r\n * NOTE: This class is auto generated by the swagger code generator program.\r\n * https://github.com/swagger-api/swagger-codegen.git\r\n * Do not edit the class manually.\r\n */\r\n/* tslint:disable:no-unused-variable member-ordering */\r\n\r\nimport { Inject, Injectable, Optional }                      from '@angular/core';\r\nimport { HttpClient, HttpHeaders, HttpParams,\r\n         HttpResponse, HttpEvent }                           from '@angular/common/http';\r\nimport { CustomHttpUrlEncodingCodec }                        from '../encoder';\r\n\r\nimport { Observable }                                        from 'rxjs';\r\n\r\nimport { Job } from '../model/job';\r\n\r\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\r\nimport { Configuration }                                     from '../configuration';\r\n\r\n\r\n@Injectable()\r\nexport class YamlService {\r\n\r\n    protected basePath = 'http://localhost:9000';\r\n    public defaultHeaders = new HttpHeaders();\r\n    public configuration = new Configuration();\r\n\r\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {\r\n        if (basePath) {\r\n            this.basePath = basePath;\r\n        }\r\n        if (configuration) {\r\n            this.configuration = configuration;\r\n            this.basePath = basePath || configuration.basePath || this.basePath;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @param consumes string[] mime-types\r\n     * @return true: consumes contains 'multipart/form-data', false: otherwise\r\n     */\r\n    private canConsumeForm(consumes: string[]): boolean {\r\n        const form = 'multipart/form-data';\r\n        for (const consume of consumes) {\r\n            if (form === consume) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n\r\n    /**\r\n     * \r\n     * \r\n     * @param yaml YAML payload\r\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\r\n     * @param reportProgress flag to report request and response progress.\r\n     */\r\n    public parseYAML(yaml: string, observe?: 'body', reportProgress?: boolean): Observable<Job>;\r\n    public parseYAML(yaml: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Job>>;\r\n    public parseYAML(yaml: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Job>>;\r\n    public parseYAML(yaml: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\r\n\r\n        if (yaml === null || yaml === undefined) {\r\n            throw new Error('Required parameter yaml was null or undefined when calling parseYAML.');\r\n        }\r\n\r\n        let headers = this.defaultHeaders;\r\n\r\n        // authentication (ApiKeyAuth) required\r\n        if (this.configuration.apiKeys[\"X-API-Key\"]) {\r\n            headers = headers.set('X-API-Key', this.configuration.apiKeys[\"X-API-Key\"]);\r\n        }\r\n\r\n        // to determine the Accept header\r\n        let httpHeaderAccepts: string[] = [\r\n            'application/json'\r\n        ];\r\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\r\n        if (httpHeaderAcceptSelected != undefined) {\r\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\r\n        }\r\n\r\n        // to determine the Content-Type header\r\n        const consumes: string[] = [\r\n            'application/yaml'\r\n        ];\r\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\r\n        if (httpContentTypeSelected != undefined) {\r\n            headers = headers.set('Content-Type', httpContentTypeSelected);\r\n        }\r\n\r\n        return this.httpClient.post<Job>(`${this.basePath}/yaml`,\r\n            yaml,\r\n            {\r\n                withCredentials: this.configuration.withCredentials,\r\n                headers: headers,\r\n                observe: observe,\r\n                reportProgress: reportProgress\r\n            }\r\n        );\r\n    }\r\n\r\n}\r\n","export * from './cloud.service';\r\nimport { CloudService } from './cloud.service';\r\nexport * from './job.service';\r\nimport { JobService } from './job.service';\r\nexport * from './matchmaking.service';\r\nimport { MatchmakingService } from './matchmaking.service';\r\nexport * from './misc.service';\r\nimport { MiscService } from './misc.service';\r\nexport * from './monitoring.service';\r\nimport { MonitoringService } from './monitoring.service';\r\nexport * from './node.service';\r\nimport { NodeService } from './node.service';\r\n// export * from './platform.service';\r\n// import { PlatformService } from './platform.service';\r\nexport * from './process.service';\r\nimport { ProcessService } from './process.service';\r\nexport * from './queue.service';\r\nimport { QueueService } from './queue.service';\r\nexport * from './scale.service';\r\nimport { ScaleService } from './scale.service';\r\nexport * from './security.service';\r\nimport { SecurityService } from './security.service';\r\nexport * from './user.service';\r\nimport { UserService } from './user.service';\r\nexport * from './yaml.service';\r\nimport { YamlService } from './yaml.service';\r\nexport const APIS = [CloudService, JobService, MatchmakingService, MiscService, MonitoringService, NodeService, /*PlatformService*/, ProcessService, QueueService, ScaleService, SecurityService, UserService, YamlService];\r\n","/**\r\n * Cloudiator REST Api\r\n * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)\r\n *\r\n * OpenAPI spec version: 0.2.0\r\n * Contact: daniel.baur@uni-ulm.de\r\n *\r\n * NOTE: This class is auto generated by the swagger code generator program.\r\n * https://github.com/swagger-api/swagger-codegen.git\r\n * Do not edit the class manually.\r\n */\r\n\r\n\r\n/**\r\n * Data Sink where the monitoring data will be reported to. \r\n */\r\nexport interface DataSink { \r\n    type?: DataSink.TypeEnum;\r\n    configuration?: any;\r\n}\r\nexport namespace DataSink {\r\n    export type TypeEnum = 'KAIROS_DB' | 'INFLUX' | 'CLI' | 'JMS';\r\n    export const TypeEnum = {\r\n        KAIROSDB: 'KAIROS_DB' as TypeEnum,\r\n        INFLUX: 'INFLUX' as TypeEnum,\r\n        CLI: 'CLI' as TypeEnum,\r\n        JMS: 'JMS' as TypeEnum\r\n    };\r\n}\r\n","/**\r\n * Cloudiator REST Api\r\n * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)\r\n *\r\n * OpenAPI spec version: 0.2.0\r\n * Contact: daniel.baur@uni-ulm.de\r\n *\r\n * NOTE: This class is auto generated by the swagger code generator program.\r\n * https://github.com/swagger-api/swagger-codegen.git\r\n * Do not edit the class manually.\r\n */\r\n\r\n\r\n/**\r\n * A time interval consisting of unit and period\r\n */\r\nexport interface Interval { \r\n    /**\r\n     * The unit of the interval\r\n     */\r\n    unit?: Interval.UnitEnum;\r\n    /**\r\n     * The period of the interval\r\n     */\r\n    period?: number;\r\n}\r\nexport namespace Interval {\r\n    export type UnitEnum = 'DAYS' | 'HOURS' | 'MICROSECONDS' | 'MILLISECONDS' | 'MINUTES' | 'NANOSECONDS' | 'SECONDS';\r\n    export const UnitEnum = {\r\n        DAYS: 'DAYS' as UnitEnum,\r\n        HOURS: 'HOURS' as UnitEnum,\r\n        MICROSECONDS: 'MICROSECONDS' as UnitEnum,\r\n        MILLISECONDS: 'MILLISECONDS' as UnitEnum,\r\n        MINUTES: 'MINUTES' as UnitEnum,\r\n        NANOSECONDS: 'NANOSECONDS' as UnitEnum,\r\n        SECONDS: 'SECONDS' as UnitEnum\r\n    };\r\n}\r\n","/**\r\n * Cloudiator REST Api\r\n * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)\r\n *\r\n * OpenAPI spec version: 0.2.0\r\n * Contact: daniel.baur@uni-ulm.de\r\n *\r\n * NOTE: This class is auto generated by the swagger code generator program.\r\n * https://github.com/swagger-api/swagger-codegen.git\r\n * Do not edit the class manually.\r\n */\r\n\r\n\r\nexport type IpAddressType = 'PUBLIC_IP' | 'PRIVATE_IP';\r\n\r\nexport const IpAddressType = {\r\n    PUBLICIP: 'PUBLIC_IP' as IpAddressType,\r\n    PRIVATEIP: 'PRIVATE_IP' as IpAddressType\r\n};\r\n","/**\r\n * Cloudiator REST Api\r\n * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)\r\n *\r\n * OpenAPI spec version: 0.2.0\r\n * Contact: daniel.baur@uni-ulm.de\r\n *\r\n * NOTE: This class is auto generated by the swagger code generator program.\r\n * https://github.com/swagger-api/swagger-codegen.git\r\n * Do not edit the class manually.\r\n */\r\n\r\n\r\n/**\r\n * Represents a runtime for a Platform component, e.g. Java, PHP, Tomcat\r\n */\r\nexport interface NewPlatformRuntime { \r\n    /**\r\n     * human readable name\r\n     */\r\n    name: string;\r\n    /**\r\n     * the specific runtime language\r\n     */\r\n    language: NewPlatformRuntime.LanguageEnum;\r\n    /**\r\n     * language version number\r\n     */\r\n    languageVersion?: number;\r\n    /**\r\n     * specifies the runtime type\r\n     */\r\n    runtimeType: NewPlatformRuntime.RuntimeTypeEnum;\r\n    /**\r\n     * the version of the specified type\r\n     */\r\n    version: number;\r\n}\r\nexport namespace NewPlatformRuntime {\r\n    export type LanguageEnum = 'PHP' | 'JAVA' | 'RUBY' | 'PYTHON';\r\n    export const LanguageEnum = {\r\n        PHP: 'PHP' as LanguageEnum,\r\n        JAVA: 'JAVA' as LanguageEnum,\r\n        RUBY: 'RUBY' as LanguageEnum,\r\n        PYTHON: 'PYTHON' as LanguageEnum\r\n    };\r\n    export type RuntimeTypeEnum = 'standalone' | 'server';\r\n    export const RuntimeTypeEnum = {\r\n        Standalone: 'standalone' as RuntimeTypeEnum,\r\n        Server: 'server' as RuntimeTypeEnum\r\n    };\r\n}\r\n","/**\r\n * Cloudiator REST Api\r\n * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)\r\n *\r\n * OpenAPI spec version: 0.2.0\r\n * Contact: daniel.baur@uni-ulm.de\r\n *\r\n * NOTE: This class is auto generated by the swagger code generator program.\r\n * https://github.com/swagger-api/swagger-codegen.git\r\n * Do not edit the class manually.\r\n */\r\nimport { DiscoveryItemState } from './discoveryItemState';\r\nimport { GeoLocation } from './geoLocation';\r\n\r\n\r\n/**\r\n * Repesents a (virtual) location offers by a cloud \r\n */\r\nexport interface Location { \r\n    /**\r\n     * Unique identifier\r\n     */\r\n    id: string;\r\n    /**\r\n     * Human-readable name\r\n     */\r\n    name: string;\r\n    /**\r\n     * Original id issued by the provider\r\n     */\r\n    providerId: string;\r\n    /**\r\n     * Scope of the location\r\n     */\r\n    locationScope: Location.LocationScopeEnum;\r\n    /**\r\n     * True of the location can be used to start virtual machines, false if not\r\n     */\r\n    isAssignable: boolean;\r\n    geoLocation?: GeoLocation;\r\n    parent?: Location;\r\n    state?: DiscoveryItemState;\r\n    owner?: string;\r\n}\r\nexport namespace Location {\r\n    export type LocationScopeEnum = 'PROVIDER' | 'REGION' | 'ZONE' | 'HOST';\r\n    export const LocationScopeEnum = {\r\n        PROVIDER: 'PROVIDER' as LocationScopeEnum,\r\n        REGION: 'REGION' as LocationScopeEnum,\r\n        ZONE: 'ZONE' as LocationScopeEnum,\r\n        HOST: 'HOST' as LocationScopeEnum\r\n    };\r\n}\r\n","/**\r\n * Cloudiator REST Api\r\n * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)\r\n *\r\n * OpenAPI spec version: 0.2.0\r\n * Contact: daniel.baur@uni-ulm.de\r\n *\r\n * NOTE: This class is auto generated by the swagger code generator program.\r\n * https://github.com/swagger-api/swagger-codegen.git\r\n * Do not edit the class manually.\r\n */\r\n\r\n\r\nexport interface MonitoringTarget { \r\n    /**\r\n     * target to be monitored\r\n     */\r\n    type: MonitoringTarget.TypeEnum;\r\n    /**\r\n     * identifier of a specific instance of the above type\r\n     */\r\n    identifier?: string;\r\n}\r\nexport namespace MonitoringTarget {\r\n    export type TypeEnum = 'JOB' | 'TASK' | 'PROCESS' | 'CLOUD' | 'NODE';\r\n    export const TypeEnum = {\r\n        JOB: 'JOB' as TypeEnum,\r\n        TASK: 'TASK' as TypeEnum,\r\n        PROCESS: 'PROCESS' as TypeEnum,\r\n        CLOUD: 'CLOUD' as TypeEnum,\r\n        NODE: 'NODE' as TypeEnum\r\n    };\r\n}\r\n","/**\r\n * Cloudiator REST Api\r\n * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)\r\n *\r\n * OpenAPI spec version: 0.2.0\r\n * Contact: daniel.baur@uni-ulm.de\r\n *\r\n * NOTE: This class is auto generated by the swagger code generator program.\r\n * https://github.com/swagger-api/swagger-codegen.git\r\n * Do not edit the class manually.\r\n */\r\nimport { Api } from './api';\r\nimport { CloudCredential } from './cloudCredential';\r\n\r\n\r\n/**\r\n * Repesents a new PaaS provider to be created \r\n */\r\nexport interface NewPlatform { \r\n    /**\r\n     * Human-readable name\r\n     */\r\n    name: string;\r\n    /**\r\n     * PaaS stack type\r\n     */\r\n    type?: NewPlatform.TypeEnum;\r\n    api: Api;\r\n    credential: CloudCredential;\r\n    /**\r\n     * URI where the api of this platform provider can be accessed.\r\n     */\r\n    endpoint?: string;\r\n}\r\nexport namespace NewPlatform {\r\n    export type TypeEnum = 'HEROKU' | 'OPENSHIFT' | 'CLOUDFOUNDRY';\r\n    export const TypeEnum = {\r\n        HEROKU: 'HEROKU' as TypeEnum,\r\n        OPENSHIFT: 'OPENSHIFT' as TypeEnum,\r\n        CLOUDFOUNDRY: 'CLOUDFOUNDRY' as TypeEnum\r\n    };\r\n}\r\n","/**\r\n * Cloudiator REST Api\r\n * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)\r\n *\r\n * OpenAPI spec version: 0.2.0\r\n * Contact: daniel.baur@uni-ulm.de\r\n *\r\n * NOTE: This class is auto generated by the swagger code generator program.\r\n * https://github.com/swagger-api/swagger-codegen.git\r\n * Do not edit the class manually.\r\n */\r\nimport { Cloud } from './cloud';\r\nimport { Environment } from './environment';\r\nimport { Hardware } from './hardware';\r\nimport { Image } from './image';\r\nimport { Location } from './location';\r\n\r\n\r\n/**\r\n * A node creatable by the system\r\n */\r\nexport interface NodeCandidate { \r\n    id?: string;\r\n    nodeCandidateType?: NodeCandidate.NodeCandidateTypeEnum;\r\n    price?: number;\r\n    cloud?: Cloud;\r\n    image?: Image;\r\n    hardware?: Hardware;\r\n    location?: Location;\r\n    pricePerInvocation?: number;\r\n    memoryPrice?: number;\r\n    environment?: Environment;\r\n}\r\nexport namespace NodeCandidate {\r\n    export type NodeCandidateTypeEnum = 'IAAS' | 'FAAS' | 'PAAS' | 'BYON';\r\n    export const NodeCandidateTypeEnum = {\r\n        IAAS: 'IAAS' as NodeCandidateTypeEnum,\r\n        FAAS: 'FAAS' as NodeCandidateTypeEnum,\r\n        PAAS: 'PAAS' as NodeCandidateTypeEnum,\r\n        BYON: 'BYON' as NodeCandidateTypeEnum\r\n    };\r\n}\r\n","/**\r\n * Cloudiator REST Api\r\n * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)\r\n *\r\n * OpenAPI spec version: 0.2.0\r\n * Contact: daniel.baur@uni-ulm.de\r\n *\r\n * NOTE: This class is auto generated by the swagger code generator program.\r\n * https://github.com/swagger-api/swagger-codegen.git\r\n * Do not edit the class manually.\r\n */\r\n\r\n\r\n/**\r\n * Superclass for polymorphism, only subtypes are allowed\r\n */\r\nexport interface Optimization { \r\n    type: string;\r\n    objective?: Optimization.ObjectiveEnum;\r\n}\r\nexport namespace Optimization {\r\n    export type ObjectiveEnum = 'MAXIMIZE' | 'MINIMIZE';\r\n    export const ObjectiveEnum = {\r\n        MAXIMIZE: 'MAXIMIZE' as ObjectiveEnum,\r\n        MINIMIZE: 'MINIMIZE' as ObjectiveEnum\r\n    };\r\n}\r\n","/**\r\n * Cloudiator REST Api\r\n * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)\r\n *\r\n * OpenAPI spec version: 0.2.0\r\n * Contact: daniel.baur@uni-ulm.de\r\n *\r\n * NOTE: This class is auto generated by the swagger code generator program.\r\n * https://github.com/swagger-api/swagger-codegen.git\r\n * Do not edit the class manually.\r\n */\r\n\r\n\r\n/**\r\n * Scaling action object containing the required information to scale an Cloudiator cluster process \r\n */\r\nexport interface Scale { \r\n    /**\r\n     * The identifier of the schedule\r\n     */\r\n    schedule?: string;\r\n    /**\r\n     * The identifier of the task\r\n     */\r\n    task?: string;\r\n    scaleDirection?: Scale.ScaleDirectionEnum;\r\n    /**\r\n     * An optional list of nodes for the scaling process\r\n     */\r\n    nodes?: Array<string>;\r\n}\r\nexport namespace Scale {\r\n    export type ScaleDirectionEnum = 'SCALE_IN' | 'SCALE_OUT';\r\n    export const ScaleDirectionEnum = {\r\n        IN: 'SCALE_IN' as ScaleDirectionEnum,\r\n        OUT: 'SCALE_OUT' as ScaleDirectionEnum\r\n    };\r\n}\r\n","/**\r\n * Cloudiator REST Api\r\n * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)\r\n *\r\n * OpenAPI spec version: 0.2.0\r\n * Contact: daniel.baur@uni-ulm.de\r\n *\r\n * NOTE: This class is auto generated by the swagger code generator program.\r\n * https://github.com/swagger-api/swagger-codegen.git\r\n * Do not edit the class manually.\r\n */\r\n\r\n\r\n/**\r\n * Schedules an already created job within the system. \r\n */\r\nexport interface ScheduleNew { \r\n    /**\r\n     * The identifier of the job\r\n     */\r\n    job?: string;\r\n    /**\r\n     * If the instantiation should be handled AUTOMATIC or MANUAL\r\n     */\r\n    instantiation?: ScheduleNew.InstantiationEnum;\r\n}\r\nexport namespace ScheduleNew {\r\n    export type InstantiationEnum = 'AUTOMATIC' | 'MANUAL';\r\n    export const InstantiationEnum = {\r\n        AUTOMATIC: 'AUTOMATIC' as InstantiationEnum,\r\n        MANUAL: 'MANUAL' as InstantiationEnum\r\n    };\r\n}\r\n","/**\r\n * Cloudiator REST Api\r\n * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)\r\n *\r\n * OpenAPI spec version: 0.2.0\r\n * Contact: daniel.baur@uni-ulm.de\r\n *\r\n * NOTE: This class is auto generated by the swagger code generator program.\r\n * https://github.com/swagger-api/swagger-codegen.git\r\n * Do not edit the class manually.\r\n */\r\n\r\n\r\n/**\r\n * a Cloudiator tool to be installed on a node\r\n */\r\nexport type Tool = 'DOCKER' | 'KAIROSDB' | 'LANCE' | 'VISOR' | 'AXE' | 'SPARK_WORKER' | 'DLMS_AGENT' | 'ALLUXIO_CLIENT' | 'EMS_CLIENT';\r\n\r\nexport const Tool = {\r\n    DOCKER: 'DOCKER' as Tool,\r\n    KAIROSDB: 'KAIROSDB' as Tool,\r\n    LANCE: 'LANCE' as Tool,\r\n    VISOR: 'VISOR' as Tool,\r\n    AXE: 'AXE' as Tool,\r\n    SPARKWORKER: 'SPARK_WORKER' as Tool,\r\n    DLMSAGENT: 'DLMS_AGENT' as Tool,\r\n    ALLUXIOCLIENT: 'ALLUXIO_CLIENT' as Tool,\r\n    EMSCLIENT: 'EMS_CLIENT' as Tool\r\n};\r\n","/**\r\n * Cloudiator REST Api\r\n * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)\r\n *\r\n * OpenAPI spec version: 0.2.0\r\n * Contact: daniel.baur@uni-ulm.de\r\n *\r\n * NOTE: This class is auto generated by the swagger code generator program.\r\n * https://github.com/swagger-api/swagger-codegen.git\r\n * Do not edit the class manually.\r\n */\r\nimport { IpAddress } from './ipAddress';\r\nimport { LoginCredential } from './loginCredential';\r\nimport { NewNode } from './newNode';\r\nimport { NodeProperties } from './nodeProperties';\r\n\r\n\r\n/**\r\n * Representation of a node used by Cloudiator\r\n */\r\nexport interface Node { \r\n    /**\r\n     * Human-readable name for the node. \r\n     */\r\n    name?: string;\r\n    loginCredential?: LoginCredential;\r\n    /**\r\n     * The public/private ip addresses under which this node is reachable. \r\n     */\r\n    ipAddresses?: Array<IpAddress>;\r\n    /**\r\n     * Further properties of this node. \r\n     */\r\n    nodeProperties?: NodeProperties;\r\n    /**\r\n     * Reason this node was created \r\n     */\r\n    reason?: string;\r\n    /**\r\n     * Diagnostic information about the node state \r\n     */\r\n    diagnostic?: string;\r\n    /**\r\n     * The node candidate this node was created from if applicable. \r\n     */\r\n    nodeCandidate?: string;\r\n    /**\r\n     * Unique identifier of this node. \r\n     */\r\n    id?: string;\r\n    /**\r\n     * Original id of this node. Is present of the node was created e.g. at a cloud provider. \r\n     */\r\n    originId?: string;\r\n    /**\r\n     * User id of the owner of this node. \r\n     */\r\n    userId?: string;\r\n    /**\r\n     * The type of this node. \r\n     */\r\n    nodeType?: Node.NodeTypeEnum;\r\n    /**\r\n     * The state the node is currently in. \r\n     */\r\n    state?: Node.StateEnum;\r\n}\r\nexport namespace Node {\r\n    export type NodeTypeEnum = 'UNKNOWN_TYPE' | 'VM' | 'BYON' | 'CONTAINER' | 'FAAS';\r\n    export const NodeTypeEnum = {\r\n        UNKNOWNTYPE: 'UNKNOWN_TYPE' as NodeTypeEnum,\r\n        VM: 'VM' as NodeTypeEnum,\r\n        BYON: 'BYON' as NodeTypeEnum,\r\n        CONTAINER: 'CONTAINER' as NodeTypeEnum,\r\n        FAAS: 'FAAS' as NodeTypeEnum\r\n    };\r\n    export type StateEnum = 'PENDING' | 'RUNNING' | 'ERROR' | 'DELETED';\r\n    export const StateEnum = {\r\n        PENDING: 'PENDING' as StateEnum,\r\n        RUNNING: 'RUNNING' as StateEnum,\r\n        ERROR: 'ERROR' as StateEnum,\r\n        DELETED: 'DELETED' as StateEnum\r\n    };\r\n}\r\n","/**\r\n * Cloudiator REST Api\r\n * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)\r\n *\r\n * OpenAPI spec version: 0.2.0\r\n * Contact: daniel.baur@uni-ulm.de\r\n *\r\n * NOTE: This class is auto generated by the swagger code generator program.\r\n * https://github.com/swagger-api/swagger-codegen.git\r\n * Do not edit the class manually.\r\n */\r\nimport { NewPlatformRuntime } from './newPlatformRuntime';\r\n\r\n\r\n/**\r\n * Repesents a PaaS environemnt to run an component \r\n */\r\nexport interface PlatformRuntime { \r\n    /**\r\n     * human readable name\r\n     */\r\n    name: string;\r\n    /**\r\n     * the specific runtime language\r\n     */\r\n    language: PlatformRuntime.LanguageEnum;\r\n    /**\r\n     * language version number\r\n     */\r\n    languageVersion?: number;\r\n    /**\r\n     * specifies the runtime type\r\n     */\r\n    runtimeType: PlatformRuntime.RuntimeTypeEnum;\r\n    /**\r\n     * the version of the specified type\r\n     */\r\n    version: number;\r\n    /**\r\n     * Unique identifier for the hardwareRuntime\r\n     */\r\n    id?: string;\r\n}\r\nexport namespace PlatformRuntime {\r\n    export type LanguageEnum = 'PHP' | 'JAVA' | 'RUBY' | 'PYTHON';\r\n    export const LanguageEnum = {\r\n        PHP: 'PHP' as LanguageEnum,\r\n        JAVA: 'JAVA' as LanguageEnum,\r\n        RUBY: 'RUBY' as LanguageEnum,\r\n        PYTHON: 'PYTHON' as LanguageEnum\r\n    };\r\n    export type RuntimeTypeEnum = 'standalone' | 'server';\r\n    export const RuntimeTypeEnum = {\r\n        Standalone: 'standalone' as RuntimeTypeEnum,\r\n        Server: 'server' as RuntimeTypeEnum\r\n    };\r\n}\r\n","/**\r\n * Cloudiator REST Api\r\n * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)\r\n *\r\n * OpenAPI spec version: 0.2.0\r\n * Contact: daniel.baur@uni-ulm.de\r\n *\r\n * NOTE: This class is auto generated by the swagger code generator program.\r\n * https://github.com/swagger-api/swagger-codegen.git\r\n * Do not edit the class manually.\r\n */\r\nimport { CloudiatorProcess } from './cloudiatorProcess';\r\nimport { ScheduleNew } from './scheduleNew';\r\n\r\n\r\nexport interface Schedule { \r\n    /**\r\n     * The identifier of the job\r\n     */\r\n    job?: string;\r\n    /**\r\n     * If the instantiation should be handled AUTOMATIC or MANUAL\r\n     */\r\n    instantiation?: Schedule.InstantiationEnum;\r\n    id?: string;\r\n    owner?: string;\r\n    processes?: Array<CloudiatorProcess>;\r\n    state?: Schedule.StateEnum;\r\n}\r\nexport namespace Schedule {\r\n    export type InstantiationEnum = 'AUTOMATIC' | 'MANUAL';\r\n    export const InstantiationEnum = {\r\n        AUTOMATIC: 'AUTOMATIC' as InstantiationEnum,\r\n        MANUAL: 'MANUAL' as InstantiationEnum\r\n    };\r\n    export type StateEnum = 'PENDING' | 'RUNNING' | 'ERROR' | 'RESTORING' | 'DELETED' | 'MANUAL';\r\n    export const StateEnum = {\r\n        PENDING: 'PENDING' as StateEnum,\r\n        RUNNING: 'RUNNING' as StateEnum,\r\n        ERROR: 'ERROR' as StateEnum,\r\n        RESTORING: 'RESTORING' as StateEnum,\r\n        DELETED: 'DELETED' as StateEnum,\r\n        MANUAL: 'MANUAL' as StateEnum\r\n    };\r\n}\r\n","/**\r\n * Cloudiator REST Api\r\n * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)\r\n *\r\n * OpenAPI spec version: 0.2.0\r\n * Contact: daniel.baur@uni-ulm.de\r\n *\r\n * NOTE: This class is auto generated by the swagger code generator program.\r\n * https://github.com/swagger-api/swagger-codegen.git\r\n * Do not edit the class manually.\r\n */\r\nimport { Hardware } from './hardware';\r\nimport { Image } from './image';\r\nimport { IpAddress } from './ipAddress';\r\nimport { Location } from './location';\r\nimport { LoginCredential } from './loginCredential';\r\n\r\n\r\nexport interface VirtualMachine { \r\n    image?: Image;\r\n    hardware?: Hardware;\r\n    location?: Location;\r\n    id?: string;\r\n    ipaddresses?: Array<IpAddress>;\r\n    logincredential?: LoginCredential;\r\n    owner?: string;\r\n    state?: VirtualMachine.StateEnum;\r\n}\r\nexport namespace VirtualMachine {\r\n    export type StateEnum = 'RUNNING' | 'ERROR';\r\n    export const StateEnum = {\r\n        RUNNING: 'RUNNING' as StateEnum,\r\n        ERROR: 'ERROR' as StateEnum\r\n    };\r\n}\r\n","/**\r\n * Cloudiator REST Api\r\n * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)\r\n *\r\n * OpenAPI spec version: 0.2.0\r\n * Contact: daniel.baur@uni-ulm.de\r\n *\r\n * NOTE: This class is auto generated by the swagger code generator program.\r\n * https://github.com/swagger-api/swagger-codegen.git\r\n * Do not edit the class manually.\r\n */\r\nimport { Optimization } from './optimization';\r\n\r\n\r\n/**\r\n * Refers to the attribute that should be optimized\r\n */\r\nexport interface AttributeOptimization extends Optimization { \r\n    objectiveClass?: string;\r\n    objectiveAttribute?: string;\r\n    aggregation?: AttributeOptimization.AggregationEnum;\r\n}\r\nexport namespace AttributeOptimization {\r\n    export type AggregationEnum = 'SUM' | 'AVG';\r\n    export const AggregationEnum = {\r\n        SUM: 'SUM' as AggregationEnum,\r\n        AVG: 'AVG' as AggregationEnum\r\n    };\r\n}\r\n","/**\r\n * Cloudiator REST Api\r\n * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)\r\n *\r\n * OpenAPI spec version: 0.2.0\r\n * Contact: daniel.baur@uni-ulm.de\r\n *\r\n * NOTE: This class is auto generated by the swagger code generator program.\r\n * https://github.com/swagger-api/swagger-codegen.git\r\n * Do not edit the class manually.\r\n */\r\nimport { Api } from './api';\r\nimport { CloudConfiguration } from './cloudConfiguration';\r\nimport { CloudCredential } from './cloudCredential';\r\nimport { CloudType } from './cloudType';\r\nimport { NewCloud } from './newCloud';\r\n\r\n\r\n/**\r\n * Representation of a cloud used by Cloudiator \r\n */\r\nexport interface Cloud { \r\n    /**\r\n     * URI where the api of this cloud provider can be accessed.\r\n     */\r\n    endpoint?: string;\r\n    cloudType: CloudType;\r\n    api: Api;\r\n    credential: CloudCredential;\r\n    cloudConfiguration?: CloudConfiguration;\r\n    /**\r\n     * Unique identifier for the cloud\r\n     */\r\n    id?: string;\r\n    /**\r\n     * Id of the user owning this cloud. \r\n     */\r\n    owner?: string;\r\n    /**\r\n     * State of the cloud\r\n     */\r\n    state?: Cloud.StateEnum;\r\n    /**\r\n     * Diagnostic information for the cloud\r\n     */\r\n    diagnostic?: string;\r\n}\r\nexport namespace Cloud {\r\n    export type StateEnum = 'OK' | 'ERROR';\r\n    export const StateEnum = {\r\n        OK: 'OK' as StateEnum,\r\n        ERROR: 'ERROR' as StateEnum\r\n    };\r\n}\r\n","/**\r\n * Cloudiator REST Api\r\n * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)\r\n *\r\n * OpenAPI spec version: 0.2.0\r\n * Contact: daniel.baur@uni-ulm.de\r\n *\r\n * NOTE: This class is auto generated by the swagger code generator program.\r\n * https://github.com/swagger-api/swagger-codegen.git\r\n * Do not edit the class manually.\r\n */\r\nimport { OperatingSystem } from './operatingSystem';\r\nimport { TaskInterface } from './taskInterface';\r\n\r\n\r\n/**\r\n * Part of a task. Subtype of TaskInterface. \r\n */\r\nexport interface LanceInterface extends TaskInterface { \r\n    /**\r\n     * The container type that lance should use. Can be DOCKER to force a docker deployment, NATIVE to force a plain container deployment or BOTH to let the system derive the container type. \r\n     */\r\n    containerType?: LanceInterface.ContainerTypeEnum;\r\n    /**\r\n     * Describes the operating system required by this interface. If container type is set to NATIVE, this describes the OS required by the scripts, of container type is set to DOCKER, this describes the OS used to spawn the docker container. \r\n     */\r\n    operatingSystem?: OperatingSystem;\r\n    /**\r\n     * Initialization action. \r\n     */\r\n    init?: string;\r\n    /**\r\n     * Executed before installation action. Can be e.g. used for downloading binaries. \r\n     */\r\n    preInstall?: string;\r\n    /**\r\n     * Used for installing the application. \r\n     */\r\n    install?: string;\r\n    /**\r\n     * Used for configuration of the application component. First action where Lance environment variables are set. \r\n     */\r\n    postInstall?: string;\r\n    /**\r\n     * Called before starting the application. Can be e.g. used for configuration an environment. \r\n     */\r\n    preStart?: string;\r\n    /**\r\n     * Starts the component. Needs to return for PlainContainer and not return for Docker. \r\n     */\r\n    start?: string;\r\n    /**\r\n     * Detects the start of the application. Required if the application does not start instantianous. \r\n     */\r\n    startDetection?: string;\r\n    /**\r\n     * Checks if the application has stopped. Is periodically checked to detect a crash of the application. \r\n     */\r\n    stopDetection?: string;\r\n    /**\r\n     * Executed after the application has successfully started. \r\n     */\r\n    postStart?: string;\r\n    /**\r\n     * Called before the application is stopped. \r\n     */\r\n    preStop?: string;\r\n    /**\r\n     * Stops the application. \r\n     */\r\n    stop?: string;\r\n    /**\r\n     * Executed after the application is successfully stopped. \r\n     */\r\n    postStop?: string;\r\n    /**\r\n     * Executed before the container is shutdown. Can be used to backup state. \r\n     */\r\n    shutdown?: string;\r\n    /**\r\n     * A script that is executed if a new instance of a downstream task is available. \r\n     */\r\n    updateAction?: string;\r\n}\r\nexport namespace LanceInterface {\r\n    export type ContainerTypeEnum = 'NATIVE' | 'DOCKER' | 'BOTH';\r\n    export const ContainerTypeEnum = {\r\n        NATIVE: 'NATIVE' as ContainerTypeEnum,\r\n        DOCKER: 'DOCKER' as ContainerTypeEnum,\r\n        BOTH: 'BOTH' as ContainerTypeEnum\r\n    };\r\n}\r\n","/**\r\n * Cloudiator REST Api\r\n * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)\r\n *\r\n * OpenAPI spec version: 0.2.0\r\n * Contact: daniel.baur@uni-ulm.de\r\n *\r\n * NOTE: This class is auto generated by the swagger code generator program.\r\n * https://github.com/swagger-api/swagger-codegen.git\r\n * Do not edit the class manually.\r\n */\r\nimport { Behaviour } from './behaviour';\r\nimport { Interval } from './interval';\r\n\r\n\r\n/**\r\n * Subtype of Behaviour Represents a periodic runtime behaviour \r\n */\r\nexport interface PeriodicBehaviour extends Behaviour { \r\n    interval?: Interval;\r\n    collisionHandling?: PeriodicBehaviour.CollisionHandlingEnum;\r\n}\r\nexport namespace PeriodicBehaviour {\r\n    export type CollisionHandlingEnum = 'CANCEL' | 'PARALLEL' | 'SKIP';\r\n    export const CollisionHandlingEnum = {\r\n        CANCEL: 'CANCEL' as CollisionHandlingEnum,\r\n        PARALLEL: 'PARALLEL' as CollisionHandlingEnum,\r\n        SKIP: 'SKIP' as CollisionHandlingEnum\r\n    };\r\n}\r\n","/**\r\n * Cloudiator REST Api\r\n * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)\r\n *\r\n * OpenAPI spec version: 0.2.0\r\n * Contact: daniel.baur@uni-ulm.de\r\n *\r\n * NOTE: This class is auto generated by the swagger code generator program.\r\n * https://github.com/swagger-api/swagger-codegen.git\r\n * Do not edit the class manually.\r\n */\r\nimport { Api } from './api';\r\nimport { CloudCredential } from './cloudCredential';\r\nimport { NewPlatform } from './newPlatform';\r\n\r\n\r\n/**\r\n * Representation of a platform used by Cloudiator\r\n */\r\nexport interface Platform { \r\n    /**\r\n     * Human-readable name\r\n     */\r\n    name: string;\r\n    /**\r\n     * PaaS stack type\r\n     */\r\n    type?: Platform.TypeEnum;\r\n    api: Api;\r\n    credential: CloudCredential;\r\n    /**\r\n     * URI where the api of this platform provider can be accessed.\r\n     */\r\n    endpoint?: string;\r\n    /**\r\n     * Unique identifier for the platform\r\n     */\r\n    id?: string;\r\n}\r\nexport namespace Platform {\r\n    export type TypeEnum = 'HEROKU' | 'OPENSHIFT' | 'CLOUDFOUNDRY';\r\n    export const TypeEnum = {\r\n        HEROKU: 'HEROKU' as TypeEnum,\r\n        OPENSHIFT: 'OPENSHIFT' as TypeEnum,\r\n        CLOUDFOUNDRY: 'CLOUDFOUNDRY' as TypeEnum\r\n    };\r\n}\r\n","/**\r\n * Cloudiator REST Api\r\n * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)\r\n *\r\n * OpenAPI spec version: 0.2.0\r\n * Contact: daniel.baur@uni-ulm.de\r\n *\r\n * NOTE: This class is auto generated by the swagger code generator program.\r\n * https://github.com/swagger-api/swagger-codegen.git\r\n * Do not edit the class manually.\r\n */\r\n/* tslint:disable:no-unused-variable member-ordering */\r\n\r\nimport { Inject, Injectable, Optional }                      from '@angular/core';\r\nimport { HttpClient, HttpHeaders, HttpParams,\r\n         HttpResponse, HttpEvent }                           from '@angular/common/http';\r\nimport { CustomHttpUrlEncodingCodec }                        from '../encoder';\r\n\r\nimport { Observable }                                        from 'rxjs';\r\n\r\nimport { NewPlatform } from '../model/newPlatform';\r\nimport { NewPlatformEnvironment } from '../model/newPlatformEnvironment';\r\nimport { NewPlatformHardware } from '../model/newPlatformHardware';\r\nimport { NewPlatformRuntime } from '../model/newPlatformRuntime';\r\nimport { Platform } from '../model/platform';\r\nimport { PlatformEnvironment } from '../model/platformEnvironment';\r\nimport { PlatformHardware } from '../model/platformHardware';\r\nimport { PlatformRuntime } from '../model/platformRuntime';\r\n\r\nimport { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';\r\nimport { Configuration }                                     from '../configuration';\r\n\r\n\r\n@Injectable()\r\nexport class PlatformService {\r\n\r\n    protected basePath = 'http://localhost:9000';\r\n    public defaultHeaders = new HttpHeaders();\r\n    public configuration = new Configuration();\r\n\r\n    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {\r\n        if (basePath) {\r\n            this.basePath = basePath;\r\n        }\r\n        if (configuration) {\r\n            this.configuration = configuration;\r\n            this.basePath = basePath || configuration.basePath || this.basePath;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @param consumes string[] mime-types\r\n     * @return true: consumes contains 'multipart/form-data', false: otherwise\r\n     */\r\n    private canConsumeForm(consumes: string[]): boolean {\r\n        const form = 'multipart/form-data';\r\n        for (const consume of consumes) {\r\n            if (form === consume) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n\r\n    /**\r\n     * \r\n     * Creates a new platform.\r\n     * @param platform Platform to add\r\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\r\n     * @param reportProgress flag to report request and response progress.\r\n     */\r\n    public addPlatform(platform: NewPlatform, observe?: 'body', reportProgress?: boolean): Observable<Platform>;\r\n    public addPlatform(platform: NewPlatform, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Platform>>;\r\n    public addPlatform(platform: NewPlatform, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Platform>>;\r\n    public addPlatform(platform: NewPlatform, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\r\n\r\n        if (platform === null || platform === undefined) {\r\n            throw new Error('Required parameter platform was null or undefined when calling addPlatform.');\r\n        }\r\n\r\n        let headers = this.defaultHeaders;\r\n\r\n        // authentication (ApiKeyAuth) required\r\n        if (this.configuration.apiKeys[\"X-API-Key\"]) {\r\n            headers = headers.set('X-API-Key', this.configuration.apiKeys[\"X-API-Key\"]);\r\n        }\r\n\r\n        // to determine the Accept header\r\n        let httpHeaderAccepts: string[] = [\r\n            'application/json'\r\n        ];\r\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\r\n        if (httpHeaderAcceptSelected != undefined) {\r\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\r\n        }\r\n\r\n        // to determine the Content-Type header\r\n        const consumes: string[] = [\r\n            'application/json'\r\n        ];\r\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\r\n        if (httpContentTypeSelected != undefined) {\r\n            headers = headers.set('Content-Type', httpContentTypeSelected);\r\n        }\r\n\r\n        return this.httpClient.post<Platform>(`${this.basePath}/platform`,\r\n            platform,\r\n            {\r\n                withCredentials: this.configuration.withCredentials,\r\n                headers: headers,\r\n                observe: observe,\r\n                reportProgress: reportProgress\r\n            }\r\n        );\r\n    }\r\n\r\n    /**\r\n     * \r\n     * Creates a new PlatformEnvironment \r\n     * @param platformEnvironment PlatformEnvironment to be created \r\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\r\n     * @param reportProgress flag to report request and response progress.\r\n     */\r\n    public addPlatformEnvironment(platformEnvironment: NewPlatformEnvironment, observe?: 'body', reportProgress?: boolean): Observable<PlatformEnvironment>;\r\n    public addPlatformEnvironment(platformEnvironment: NewPlatformEnvironment, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<PlatformEnvironment>>;\r\n    public addPlatformEnvironment(platformEnvironment: NewPlatformEnvironment, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<PlatformEnvironment>>;\r\n    public addPlatformEnvironment(platformEnvironment: NewPlatformEnvironment, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\r\n\r\n        if (platformEnvironment === null || platformEnvironment === undefined) {\r\n            throw new Error('Required parameter platformEnvironment was null or undefined when calling addPlatformEnvironment.');\r\n        }\r\n\r\n        let headers = this.defaultHeaders;\r\n\r\n        // authentication (ApiKeyAuth) required\r\n        if (this.configuration.apiKeys[\"X-API-Key\"]) {\r\n            headers = headers.set('X-API-Key', this.configuration.apiKeys[\"X-API-Key\"]);\r\n        }\r\n\r\n        // to determine the Accept header\r\n        let httpHeaderAccepts: string[] = [\r\n            'application/json'\r\n        ];\r\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\r\n        if (httpHeaderAcceptSelected != undefined) {\r\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\r\n        }\r\n\r\n        // to determine the Content-Type header\r\n        const consumes: string[] = [\r\n            'application/json'\r\n        ];\r\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\r\n        if (httpContentTypeSelected != undefined) {\r\n            headers = headers.set('Content-Type', httpContentTypeSelected);\r\n        }\r\n\r\n        return this.httpClient.post<PlatformEnvironment>(`${this.basePath}/platformEnvironment`,\r\n            platformEnvironment,\r\n            {\r\n                withCredentials: this.configuration.withCredentials,\r\n                headers: headers,\r\n                observe: observe,\r\n                reportProgress: reportProgress\r\n            }\r\n        );\r\n    }\r\n\r\n    /**\r\n     * \r\n     * Creates a new PlatformHardware \r\n     * @param platformHardware PlatformHardware to be created \r\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\r\n     * @param reportProgress flag to report request and response progress.\r\n     */\r\n    public addPlatformHardware(platformHardware: NewPlatformHardware, observe?: 'body', reportProgress?: boolean): Observable<PlatformHardware>;\r\n    public addPlatformHardware(platformHardware: NewPlatformHardware, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<PlatformHardware>>;\r\n    public addPlatformHardware(platformHardware: NewPlatformHardware, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<PlatformHardware>>;\r\n    public addPlatformHardware(platformHardware: NewPlatformHardware, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\r\n\r\n        if (platformHardware === null || platformHardware === undefined) {\r\n            throw new Error('Required parameter platformHardware was null or undefined when calling addPlatformHardware.');\r\n        }\r\n\r\n        let headers = this.defaultHeaders;\r\n\r\n        // authentication (ApiKeyAuth) required\r\n        if (this.configuration.apiKeys[\"X-API-Key\"]) {\r\n            headers = headers.set('X-API-Key', this.configuration.apiKeys[\"X-API-Key\"]);\r\n        }\r\n\r\n        // to determine the Accept header\r\n        let httpHeaderAccepts: string[] = [\r\n            'application/json'\r\n        ];\r\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\r\n        if (httpHeaderAcceptSelected != undefined) {\r\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\r\n        }\r\n\r\n        // to determine the Content-Type header\r\n        const consumes: string[] = [\r\n            'application/json'\r\n        ];\r\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\r\n        if (httpContentTypeSelected != undefined) {\r\n            headers = headers.set('Content-Type', httpContentTypeSelected);\r\n        }\r\n\r\n        return this.httpClient.post<PlatformHardware>(`${this.basePath}/platformHardware`,\r\n            platformHardware,\r\n            {\r\n                withCredentials: this.configuration.withCredentials,\r\n                headers: headers,\r\n                observe: observe,\r\n                reportProgress: reportProgress\r\n            }\r\n        );\r\n    }\r\n\r\n    /**\r\n     * \r\n     * Creates a new PlatformRuntime \r\n     * @param platformRuntime PlatformRuntime to be created \r\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\r\n     * @param reportProgress flag to report request and response progress.\r\n     */\r\n    public addPlatformRuntime(platformRuntime: NewPlatformRuntime, observe?: 'body', reportProgress?: boolean): Observable<PlatformRuntime>;\r\n    public addPlatformRuntime(platformRuntime: NewPlatformRuntime, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<PlatformRuntime>>;\r\n    public addPlatformRuntime(platformRuntime: NewPlatformRuntime, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<PlatformRuntime>>;\r\n    public addPlatformRuntime(platformRuntime: NewPlatformRuntime, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\r\n\r\n        if (platformRuntime === null || platformRuntime === undefined) {\r\n            throw new Error('Required parameter platformRuntime was null or undefined when calling addPlatformRuntime.');\r\n        }\r\n\r\n        let headers = this.defaultHeaders;\r\n\r\n        // authentication (ApiKeyAuth) required\r\n        if (this.configuration.apiKeys[\"X-API-Key\"]) {\r\n            headers = headers.set('X-API-Key', this.configuration.apiKeys[\"X-API-Key\"]);\r\n        }\r\n\r\n        // to determine the Accept header\r\n        let httpHeaderAccepts: string[] = [\r\n            'application/json'\r\n        ];\r\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\r\n        if (httpHeaderAcceptSelected != undefined) {\r\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\r\n        }\r\n\r\n        // to determine the Content-Type header\r\n        const consumes: string[] = [\r\n            'application/json'\r\n        ];\r\n        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);\r\n        if (httpContentTypeSelected != undefined) {\r\n            headers = headers.set('Content-Type', httpContentTypeSelected);\r\n        }\r\n\r\n        return this.httpClient.post<PlatformRuntime>(`${this.basePath}/platformRuntime`,\r\n            platformRuntime,\r\n            {\r\n                withCredentials: this.configuration.withCredentials,\r\n                headers: headers,\r\n                observe: observe,\r\n                reportProgress: reportProgress\r\n            }\r\n        );\r\n    }\r\n\r\n    /**\r\n     * \r\n     * Deletes the platform identified by the given id paramater. \r\n     * @param id Unique identifier of the resource\r\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\r\n     * @param reportProgress flag to report request and response progress.\r\n     */\r\n    public deletePlatform(id: string, observe?: 'body', reportProgress?: boolean): Observable<any>;\r\n    public deletePlatform(id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<any>>;\r\n    public deletePlatform(id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<any>>;\r\n    public deletePlatform(id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\r\n\r\n        if (id === null || id === undefined) {\r\n            throw new Error('Required parameter id was null or undefined when calling deletePlatform.');\r\n        }\r\n\r\n        let headers = this.defaultHeaders;\r\n\r\n        // authentication (ApiKeyAuth) required\r\n        if (this.configuration.apiKeys[\"X-API-Key\"]) {\r\n            headers = headers.set('X-API-Key', this.configuration.apiKeys[\"X-API-Key\"]);\r\n        }\r\n\r\n        // to determine the Accept header\r\n        let httpHeaderAccepts: string[] = [\r\n            'application/json'\r\n        ];\r\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\r\n        if (httpHeaderAcceptSelected != undefined) {\r\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\r\n        }\r\n\r\n        // to determine the Content-Type header\r\n        const consumes: string[] = [\r\n            'application/json'\r\n        ];\r\n\r\n        return this.httpClient.delete<any>(`${this.basePath}/platform/${encodeURIComponent(String(id))}`,\r\n            {\r\n                withCredentials: this.configuration.withCredentials,\r\n                headers: headers,\r\n                observe: observe,\r\n                reportProgress: reportProgress\r\n            }\r\n        );\r\n    }\r\n\r\n    /**\r\n     * \r\n     * Returns the platform identified by the given id parameter \r\n     * @param id Unique identifier of the resource\r\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\r\n     * @param reportProgress flag to report request and response progress.\r\n     */\r\n    public findPlatform(id: string, observe?: 'body', reportProgress?: boolean): Observable<Platform>;\r\n    public findPlatform(id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Platform>>;\r\n    public findPlatform(id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Platform>>;\r\n    public findPlatform(id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\r\n\r\n        if (id === null || id === undefined) {\r\n            throw new Error('Required parameter id was null or undefined when calling findPlatform.');\r\n        }\r\n\r\n        let headers = this.defaultHeaders;\r\n\r\n        // authentication (ApiKeyAuth) required\r\n        if (this.configuration.apiKeys[\"X-API-Key\"]) {\r\n            headers = headers.set('X-API-Key', this.configuration.apiKeys[\"X-API-Key\"]);\r\n        }\r\n\r\n        // to determine the Accept header\r\n        let httpHeaderAccepts: string[] = [\r\n            'application/json'\r\n        ];\r\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\r\n        if (httpHeaderAcceptSelected != undefined) {\r\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\r\n        }\r\n\r\n        // to determine the Content-Type header\r\n        const consumes: string[] = [\r\n        ];\r\n\r\n        return this.httpClient.get<Platform>(`${this.basePath}/platform/${encodeURIComponent(String(id))}`,\r\n            {\r\n                withCredentials: this.configuration.withCredentials,\r\n                headers: headers,\r\n                observe: observe,\r\n                reportProgress: reportProgress\r\n            }\r\n        );\r\n    }\r\n\r\n    /**\r\n     * \r\n     * Returns the PlatformEnvironment identified by the id parameter. \r\n     * @param id Unique identifier of the resource\r\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\r\n     * @param reportProgress flag to report request and response progress.\r\n     */\r\n    public findPlatformEnvironment(id: string, observe?: 'body', reportProgress?: boolean): Observable<PlatformEnvironment>;\r\n    public findPlatformEnvironment(id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<PlatformEnvironment>>;\r\n    public findPlatformEnvironment(id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<PlatformEnvironment>>;\r\n    public findPlatformEnvironment(id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\r\n\r\n        if (id === null || id === undefined) {\r\n            throw new Error('Required parameter id was null or undefined when calling findPlatformEnvironment.');\r\n        }\r\n\r\n        let headers = this.defaultHeaders;\r\n\r\n        // authentication (ApiKeyAuth) required\r\n        if (this.configuration.apiKeys[\"X-API-Key\"]) {\r\n            headers = headers.set('X-API-Key', this.configuration.apiKeys[\"X-API-Key\"]);\r\n        }\r\n\r\n        // to determine the Accept header\r\n        let httpHeaderAccepts: string[] = [\r\n            'application/json'\r\n        ];\r\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\r\n        if (httpHeaderAcceptSelected != undefined) {\r\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\r\n        }\r\n\r\n        // to determine the Content-Type header\r\n        const consumes: string[] = [\r\n        ];\r\n\r\n        return this.httpClient.get<PlatformEnvironment>(`${this.basePath}/platformEnvironment/${encodeURIComponent(String(id))}`,\r\n            {\r\n                withCredentials: this.configuration.withCredentials,\r\n                headers: headers,\r\n                observe: observe,\r\n                reportProgress: reportProgress\r\n            }\r\n        );\r\n    }\r\n\r\n    /**\r\n     * \r\n     * Returns all platform environment  visible to the user \r\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\r\n     * @param reportProgress flag to report request and response progress.\r\n     */\r\n    public findPlatformEnvironments(observe?: 'body', reportProgress?: boolean): Observable<Array<PlatformEnvironment>>;\r\n    public findPlatformEnvironments(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<PlatformEnvironment>>>;\r\n    public findPlatformEnvironments(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<PlatformEnvironment>>>;\r\n    public findPlatformEnvironments(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\r\n\r\n        let headers = this.defaultHeaders;\r\n\r\n        // authentication (ApiKeyAuth) required\r\n        if (this.configuration.apiKeys[\"X-API-Key\"]) {\r\n            headers = headers.set('X-API-Key', this.configuration.apiKeys[\"X-API-Key\"]);\r\n        }\r\n\r\n        // to determine the Accept header\r\n        let httpHeaderAccepts: string[] = [\r\n            'application/json'\r\n        ];\r\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\r\n        if (httpHeaderAcceptSelected != undefined) {\r\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\r\n        }\r\n\r\n        // to determine the Content-Type header\r\n        const consumes: string[] = [\r\n        ];\r\n\r\n        return this.httpClient.get<Array<PlatformEnvironment>>(`${this.basePath}/platformEnvironment`,\r\n            {\r\n                withCredentials: this.configuration.withCredentials,\r\n                headers: headers,\r\n                observe: observe,\r\n                reportProgress: reportProgress\r\n            }\r\n        );\r\n    }\r\n\r\n    /**\r\n     * \r\n     * Returns the PlatformHardware identified by the id parameter. \r\n     * @param id Unique identifier of the resource\r\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\r\n     * @param reportProgress flag to report request and response progress.\r\n     */\r\n    public findPlatformHardware(id: string, observe?: 'body', reportProgress?: boolean): Observable<PlatformHardware>;\r\n    public findPlatformHardware(id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<PlatformHardware>>;\r\n    public findPlatformHardware(id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<PlatformHardware>>;\r\n    public findPlatformHardware(id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\r\n\r\n        if (id === null || id === undefined) {\r\n            throw new Error('Required parameter id was null or undefined when calling findPlatformHardware.');\r\n        }\r\n\r\n        let headers = this.defaultHeaders;\r\n\r\n        // authentication (ApiKeyAuth) required\r\n        if (this.configuration.apiKeys[\"X-API-Key\"]) {\r\n            headers = headers.set('X-API-Key', this.configuration.apiKeys[\"X-API-Key\"]);\r\n        }\r\n\r\n        // to determine the Accept header\r\n        let httpHeaderAccepts: string[] = [\r\n            'application/json'\r\n        ];\r\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\r\n        if (httpHeaderAcceptSelected != undefined) {\r\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\r\n        }\r\n\r\n        // to determine the Content-Type header\r\n        const consumes: string[] = [\r\n        ];\r\n\r\n        return this.httpClient.get<PlatformHardware>(`${this.basePath}/platformHardware/${encodeURIComponent(String(id))}`,\r\n            {\r\n                withCredentials: this.configuration.withCredentials,\r\n                headers: headers,\r\n                observe: observe,\r\n                reportProgress: reportProgress\r\n            }\r\n        );\r\n    }\r\n\r\n    /**\r\n     * \r\n     * Returns all platform hardware visible to the user \r\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\r\n     * @param reportProgress flag to report request and response progress.\r\n     */\r\n    public findPlatformHardwares(observe?: 'body', reportProgress?: boolean): Observable<Array<PlatformHardware>>;\r\n    public findPlatformHardwares(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<PlatformHardware>>>;\r\n    public findPlatformHardwares(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<PlatformHardware>>>;\r\n    public findPlatformHardwares(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\r\n\r\n        let headers = this.defaultHeaders;\r\n\r\n        // authentication (ApiKeyAuth) required\r\n        if (this.configuration.apiKeys[\"X-API-Key\"]) {\r\n            headers = headers.set('X-API-Key', this.configuration.apiKeys[\"X-API-Key\"]);\r\n        }\r\n\r\n        // to determine the Accept header\r\n        let httpHeaderAccepts: string[] = [\r\n            'application/json'\r\n        ];\r\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\r\n        if (httpHeaderAcceptSelected != undefined) {\r\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\r\n        }\r\n\r\n        // to determine the Content-Type header\r\n        const consumes: string[] = [\r\n        ];\r\n\r\n        return this.httpClient.get<Array<PlatformHardware>>(`${this.basePath}/platformHardware`,\r\n            {\r\n                withCredentials: this.configuration.withCredentials,\r\n                headers: headers,\r\n                observe: observe,\r\n                reportProgress: reportProgress\r\n            }\r\n        );\r\n    }\r\n\r\n    /**\r\n     * \r\n     * Returns the PlatformRuntime identified by the id parameter. \r\n     * @param id Unique identifier of the resource\r\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\r\n     * @param reportProgress flag to report request and response progress.\r\n     */\r\n    public findPlatformRuntime(id: string, observe?: 'body', reportProgress?: boolean): Observable<PlatformRuntime>;\r\n    public findPlatformRuntime(id: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<PlatformRuntime>>;\r\n    public findPlatformRuntime(id: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<PlatformRuntime>>;\r\n    public findPlatformRuntime(id: string, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\r\n\r\n        if (id === null || id === undefined) {\r\n            throw new Error('Required parameter id was null or undefined when calling findPlatformRuntime.');\r\n        }\r\n\r\n        let headers = this.defaultHeaders;\r\n\r\n        // authentication (ApiKeyAuth) required\r\n        if (this.configuration.apiKeys[\"X-API-Key\"]) {\r\n            headers = headers.set('X-API-Key', this.configuration.apiKeys[\"X-API-Key\"]);\r\n        }\r\n\r\n        // to determine the Accept header\r\n        let httpHeaderAccepts: string[] = [\r\n            'application/json'\r\n        ];\r\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\r\n        if (httpHeaderAcceptSelected != undefined) {\r\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\r\n        }\r\n\r\n        // to determine the Content-Type header\r\n        const consumes: string[] = [\r\n        ];\r\n\r\n        return this.httpClient.get<PlatformRuntime>(`${this.basePath}/platformRuntime/${encodeURIComponent(String(id))}`,\r\n            {\r\n                withCredentials: this.configuration.withCredentials,\r\n                headers: headers,\r\n                observe: observe,\r\n                reportProgress: reportProgress\r\n            }\r\n        );\r\n    }\r\n\r\n    /**\r\n     * \r\n     * Returns all platform runtime  visible to the user \r\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\r\n     * @param reportProgress flag to report request and response progress.\r\n     */\r\n    public findPlatformRuntimes(observe?: 'body', reportProgress?: boolean): Observable<Array<PlatformRuntime>>;\r\n    public findPlatformRuntimes(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<PlatformRuntime>>>;\r\n    public findPlatformRuntimes(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<PlatformRuntime>>>;\r\n    public findPlatformRuntimes(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\r\n\r\n        let headers = this.defaultHeaders;\r\n\r\n        // authentication (ApiKeyAuth) required\r\n        if (this.configuration.apiKeys[\"X-API-Key\"]) {\r\n            headers = headers.set('X-API-Key', this.configuration.apiKeys[\"X-API-Key\"]);\r\n        }\r\n\r\n        // to determine the Accept header\r\n        let httpHeaderAccepts: string[] = [\r\n            'application/json'\r\n        ];\r\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\r\n        if (httpHeaderAcceptSelected != undefined) {\r\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\r\n        }\r\n\r\n        // to determine the Content-Type header\r\n        const consumes: string[] = [\r\n        ];\r\n\r\n        return this.httpClient.get<Array<PlatformRuntime>>(`${this.basePath}/platformRuntime`,\r\n            {\r\n                withCredentials: this.configuration.withCredentials,\r\n                headers: headers,\r\n                observe: observe,\r\n                reportProgress: reportProgress\r\n            }\r\n        );\r\n    }\r\n\r\n    /**\r\n     * \r\n     * Returns all platform from the system that the user has access to \r\n     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.\r\n     * @param reportProgress flag to report request and response progress.\r\n     */\r\n    public findPlatforms(observe?: 'body', reportProgress?: boolean): Observable<Array<Platform>>;\r\n    public findPlatforms(observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Array<Platform>>>;\r\n    public findPlatforms(observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Array<Platform>>>;\r\n    public findPlatforms(observe: any = 'body', reportProgress: boolean = false ): Observable<any> {\r\n\r\n        let headers = this.defaultHeaders;\r\n\r\n        // authentication (ApiKeyAuth) required\r\n        if (this.configuration.apiKeys[\"X-API-Key\"]) {\r\n            headers = headers.set('X-API-Key', this.configuration.apiKeys[\"X-API-Key\"]);\r\n        }\r\n\r\n        // to determine the Accept header\r\n        let httpHeaderAccepts: string[] = [\r\n            'application/json'\r\n        ];\r\n        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);\r\n        if (httpHeaderAcceptSelected != undefined) {\r\n            headers = headers.set('Accept', httpHeaderAcceptSelected);\r\n        }\r\n\r\n        // to determine the Content-Type header\r\n        const consumes: string[] = [\r\n        ];\r\n\r\n        return this.httpClient.get<Array<Platform>>(`${this.basePath}/platform`,\r\n            {\r\n                withCredentials: this.configuration.withCredentials,\r\n                headers: headers,\r\n                observe: observe,\r\n                reportProgress: reportProgress\r\n            }\r\n        );\r\n    }\r\n\r\n}\r\n","import { NgModule, ModuleWithProviders, SkipSelf, Optional } from '@angular/core';\r\nimport { Configuration } from './configuration';\r\nimport { HttpClient } from '@angular/common/http';\r\n\r\n\r\nimport { CloudService } from './api/cloud.service';\r\nimport { JobService } from './api/job.service';\r\nimport { MatchmakingService } from './api/matchmaking.service';\r\nimport { MiscService } from './api/misc.service';\r\nimport { MonitoringService } from './api/monitoring.service';\r\nimport { NodeService } from './api/node.service';\r\nimport { PlatformService } from './api/platform.service';\r\nimport { ProcessService } from './api/process.service';\r\nimport { QueueService } from './api/queue.service';\r\nimport { ScaleService } from './api/scale.service';\r\nimport { SecurityService } from './api/security.service';\r\nimport { UserService } from './api/user.service';\r\nimport { YamlService } from './api/yaml.service';\r\n\r\n@NgModule({\r\n  imports:      [],\r\n  declarations: [],\r\n  exports:      [],\r\n  providers: [\r\n    CloudService,\r\n    JobService,\r\n    MatchmakingService,\r\n    MiscService,\r\n    MonitoringService,\r\n    NodeService,\r\n    PlatformService,\r\n    ProcessService,\r\n    QueueService,\r\n    ScaleService,\r\n    SecurityService,\r\n    UserService,\r\n    YamlService ]\r\n})\r\nexport class ApiModule {\r\n    public static forRoot(configurationFactory: () => Configuration): ModuleWithProviders {\r\n        return {\r\n            ngModule: ApiModule,\r\n            providers: [ { provide: Configuration, useFactory: configurationFactory } ]\r\n        };\r\n    }\r\n\r\n    constructor( @Optional() @SkipSelf() parentModule: ApiModule,\r\n                 @Optional() http: HttpClient) {\r\n        if (parentModule) {\r\n            throw new Error('ApiModule is already loaded. Import in your base AppModule only.');\r\n        }\r\n        if (!http) {\r\n            throw new Error('You need to import the HttpClientModule in your AppModule! \\n' +\r\n            'See also https://github.com/angular/angular/issues/20575');\r\n        }\r\n    }\r\n}\r\n","/**\r\n * Cloudiator REST Api\r\n * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)\r\n *\r\n * OpenAPI spec version: 0.2.0\r\n * Contact: daniel.baur@uni-ulm.de\r\n *\r\n * NOTE: This class is auto generated by the swagger code generator program.\r\n * https://github.com/swagger-api/swagger-codegen.git\r\n * Do not edit the class manually.\r\n */\r\n\r\n\r\n/**\r\n * type of the cloud\r\n */\r\nexport type CloudType = 'PRIVATE' | 'PUBLIC';\r\n\r\nexport const CloudType = {\r\n    PRIVATE: 'PRIVATE' as CloudType,\r\n    PUBLIC: 'PUBLIC' as CloudType\r\n};\r\n","/**\r\n * Cloudiator REST Api\r\n * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)\r\n *\r\n * OpenAPI spec version: 0.2.0\r\n * Contact: daniel.baur@uni-ulm.de\r\n *\r\n * NOTE: This class is auto generated by the swagger code generator program.\r\n * https://github.com/swagger-api/swagger-codegen.git\r\n * Do not edit the class manually.\r\n */\r\n\r\n\r\nexport type DiscoveryItemState = 'NEW' | 'OK' | 'REMOTELY_DELETED' | 'LOCALLY_DELETED' | 'DISABLED' | 'DELETED' | 'UNKNOWN';\r\n\r\nexport const DiscoveryItemState = {\r\n    NEW: 'NEW' as DiscoveryItemState,\r\n    OK: 'OK' as DiscoveryItemState,\r\n    REMOTELYDELETED: 'REMOTELY_DELETED' as DiscoveryItemState,\r\n    LOCALLYDELETED: 'LOCALLY_DELETED' as DiscoveryItemState,\r\n    DISABLED: 'DISABLED' as DiscoveryItemState,\r\n    DELETED: 'DELETED' as DiscoveryItemState,\r\n    UNKNOWN: 'UNKNOWN' as DiscoveryItemState\r\n};\r\n","/**\r\n * Cloudiator REST Api\r\n * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)\r\n *\r\n * OpenAPI spec version: 0.2.0\r\n * Contact: daniel.baur@uni-ulm.de\r\n *\r\n * NOTE: This class is auto generated by the swagger code generator program.\r\n * https://github.com/swagger-api/swagger-codegen.git\r\n * Do not edit the class manually.\r\n */\r\n\r\n\r\nexport type IpVersion = 'V4' | 'V6';\r\n\r\nexport const IpVersion = {\r\n    V4: 'V4' as IpVersion,\r\n    V6: 'V6' as IpVersion\r\n};\r\n","/**\r\n * Cloudiator REST Api\r\n * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)\r\n *\r\n * OpenAPI spec version: 0.2.0\r\n * Contact: daniel.baur@uni-ulm.de\r\n *\r\n * NOTE: This class is auto generated by the swagger code generator program.\r\n * https://github.com/swagger-api/swagger-codegen.git\r\n * Do not edit the class manually.\r\n */\r\n\r\n\r\n/**\r\n * Type of OS Architecture\r\n */\r\nexport type OperatingSystemArchitecture = 'AMD64' | 'UNKOWN' | 'I386' | 'ARM';\r\n\r\nexport const OperatingSystemArchitecture = {\r\n    AMD64: 'AMD64' as OperatingSystemArchitecture,\r\n    UNKOWN: 'UNKOWN' as OperatingSystemArchitecture,\r\n    I386: 'I386' as OperatingSystemArchitecture,\r\n    ARM: 'ARM' as OperatingSystemArchitecture\r\n};\r\n","/**\r\n * Cloudiator REST Api\r\n * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)\r\n *\r\n * OpenAPI spec version: 0.2.0\r\n * Contact: daniel.baur@uni-ulm.de\r\n *\r\n * NOTE: This class is auto generated by the swagger code generator program.\r\n * https://github.com/swagger-api/swagger-codegen.git\r\n * Do not edit the class manually.\r\n */\r\n\r\n\r\n/**\r\n * Type of OS Family\r\n */\r\nexport type OperatingSystemFamily = 'UBUNTU' | 'UNKOWN_OS_FAMILY' | 'AIX' | 'ARCH' | 'CENTOS' | 'DARWIN' | 'DEBIAN' | 'ESX' | 'FEDORA' | 'FREEBSD' | 'GENTOO' | 'HPUX' | 'COREOS' | 'AMZN_LINUX' | 'MANDRIVA' | 'NETBSD' | 'OEL' | 'OPENBSD' | 'RHEL' | 'SCIENTIFIC' | 'CEL' | 'SLACKWARE' | 'SOLARIS' | 'SUSE' | 'TURBOLINUX' | 'CLOUD_LINUX' | 'WINDOWS';\r\n\r\nexport const OperatingSystemFamily = {\r\n    UBUNTU: 'UBUNTU' as OperatingSystemFamily,\r\n    UNKOWNOSFAMILY: 'UNKOWN_OS_FAMILY' as OperatingSystemFamily,\r\n    AIX: 'AIX' as OperatingSystemFamily,\r\n    ARCH: 'ARCH' as OperatingSystemFamily,\r\n    CENTOS: 'CENTOS' as OperatingSystemFamily,\r\n    DARWIN: 'DARWIN' as OperatingSystemFamily,\r\n    DEBIAN: 'DEBIAN' as OperatingSystemFamily,\r\n    ESX: 'ESX' as OperatingSystemFamily,\r\n    FEDORA: 'FEDORA' as OperatingSystemFamily,\r\n    FREEBSD: 'FREEBSD' as OperatingSystemFamily,\r\n    GENTOO: 'GENTOO' as OperatingSystemFamily,\r\n    HPUX: 'HPUX' as OperatingSystemFamily,\r\n    COREOS: 'COREOS' as OperatingSystemFamily,\r\n    AMZNLINUX: 'AMZN_LINUX' as OperatingSystemFamily,\r\n    MANDRIVA: 'MANDRIVA' as OperatingSystemFamily,\r\n    NETBSD: 'NETBSD' as OperatingSystemFamily,\r\n    OEL: 'OEL' as OperatingSystemFamily,\r\n    OPENBSD: 'OPENBSD' as OperatingSystemFamily,\r\n    RHEL: 'RHEL' as OperatingSystemFamily,\r\n    SCIENTIFIC: 'SCIENTIFIC' as OperatingSystemFamily,\r\n    CEL: 'CEL' as OperatingSystemFamily,\r\n    SLACKWARE: 'SLACKWARE' as OperatingSystemFamily,\r\n    SOLARIS: 'SOLARIS' as OperatingSystemFamily,\r\n    SUSE: 'SUSE' as OperatingSystemFamily,\r\n    TURBOLINUX: 'TURBOLINUX' as OperatingSystemFamily,\r\n    CLOUDLINUX: 'CLOUD_LINUX' as OperatingSystemFamily,\r\n    WINDOWS: 'WINDOWS' as OperatingSystemFamily\r\n};\r\n","/**\r\n * Cloudiator REST Api\r\n * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)\r\n *\r\n * OpenAPI spec version: 0.2.0\r\n * Contact: daniel.baur@uni-ulm.de\r\n *\r\n * NOTE: This class is auto generated by the swagger code generator program.\r\n * https://github.com/swagger-api/swagger-codegen.git\r\n * Do not edit the class manually.\r\n */\r\n\r\n\r\n/**\r\n * OS Type\r\n */\r\nexport type OperatingSystemType = 'LINUX' | 'UNKOWN' | 'UNIX' | 'WINDOWS_OS' | 'BSD' | 'MAC';\r\n\r\nexport const OperatingSystemType = {\r\n    LINUX: 'LINUX' as OperatingSystemType,\r\n    UNKOWN: 'UNKOWN' as OperatingSystemType,\r\n    UNIX: 'UNIX' as OperatingSystemType,\r\n    WINDOWSOS: 'WINDOWS_OS' as OperatingSystemType,\r\n    BSD: 'BSD' as OperatingSystemType,\r\n    MAC: 'MAC' as OperatingSystemType\r\n};\r\n","/**\r\n * Cloudiator REST Api\r\n * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)\r\n *\r\n * OpenAPI spec version: 0.2.0\r\n * Contact: daniel.baur@uni-ulm.de\r\n *\r\n * NOTE: This class is auto generated by the swagger code generator program.\r\n * https://github.com/swagger-api/swagger-codegen.git\r\n * Do not edit the class manually.\r\n */\r\n\r\n\r\nexport type ProcessMapping = 'SINGLE' | 'CLUSTER';\r\n\r\nexport const ProcessMapping = {\r\n    SINGLE: 'SINGLE' as ProcessMapping,\r\n    CLUSTER: 'CLUSTER' as ProcessMapping\r\n};\r\n","/**\r\n * Cloudiator REST Api\r\n * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)\r\n *\r\n * OpenAPI spec version: 0.2.0\r\n * Contact: daniel.baur@uni-ulm.de\r\n *\r\n * NOTE: This class is auto generated by the swagger code generator program.\r\n * https://github.com/swagger-api/swagger-codegen.git\r\n * Do not edit the class manually.\r\n */\r\n\r\n\r\n/**\r\n * Status of the running task \r\n */\r\nexport type QueueStatus = 'SCHEDULED' | 'RUNNING' | 'COMPLETED' | 'FAILED';\r\n\r\nexport const QueueStatus = {\r\n    SCHEDULED: 'SCHEDULED' as QueueStatus,\r\n    RUNNING: 'RUNNING' as QueueStatus,\r\n    COMPLETED: 'COMPLETED' as QueueStatus,\r\n    FAILED: 'FAILED' as QueueStatus\r\n};\r\n","/**\r\n * Cloudiator REST Api\r\n * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)\r\n *\r\n * OpenAPI spec version: 0.2.0\r\n * Contact: daniel.baur@uni-ulm.de\r\n *\r\n * NOTE: This class is auto generated by the swagger code generator program.\r\n * https://github.com/swagger-api/swagger-codegen.git\r\n * Do not edit the class manually.\r\n */\r\n\r\n\r\n/**\r\n * Part of AttributeRequirement\r\n */\r\nexport type RequirementOperator = 'EQ' | 'LEQ' | 'GEQ' | 'GT' | 'LT' | 'NEQ' | 'IN';\r\n\r\nexport const RequirementOperator = {\r\n    EQ: 'EQ' as RequirementOperator,\r\n    LEQ: 'LEQ' as RequirementOperator,\r\n    GEQ: 'GEQ' as RequirementOperator,\r\n    GT: 'GT' as RequirementOperator,\r\n    LT: 'LT' as RequirementOperator,\r\n    NEQ: 'NEQ' as RequirementOperator,\r\n    IN: 'IN' as RequirementOperator\r\n};\r\n","/**\r\n * Cloudiator REST Api\r\n * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)\r\n *\r\n * OpenAPI spec version: 0.2.0\r\n * Contact: daniel.baur@uni-ulm.de\r\n *\r\n * NOTE: This class is auto generated by the swagger code generator program.\r\n * https://github.com/swagger-api/swagger-codegen.git\r\n * Do not edit the class manually.\r\n */\r\n\r\n\r\n/**\r\n * Represents runtime provided by a FaaS platform. \r\n */\r\nexport type Runtime = 'nodejs' | 'python' | 'java' | 'dotnet' | 'go';\r\n\r\nexport const Runtime = {\r\n    Nodejs: 'nodejs' as Runtime,\r\n    Python: 'python' as Runtime,\r\n    Java: 'java' as Runtime,\r\n    Dotnet: 'dotnet' as Runtime,\r\n    Go: 'go' as Runtime\r\n};\r\n"]}